---
phase: 01-data-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - docker-compose.yml
  - docker-compose.override.yml
  - api/Dockerfile
  - .env.example
  - .env
  - .gitignore
  - .dockerignore
autonomous: true

must_haves:
  truths:
    - "docker compose up -d starts postgres (pgvector), redis, api, and worker services"
    - "PostgreSQL is accessible at localhost:5432 with pgvector extension available"
    - "Redis is accessible at localhost:6379"
    - "API service runs uvicorn with hot reload in dev mode"
    - "Worker service placeholder runs and connects to Redis"
    - "postgres service has a healthcheck that gates api and worker startup"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Base service definitions for postgres, redis, api, worker"
      contains: "pgvector/pgvector:pg17"
    - path: "docker-compose.override.yml"
      provides: "Dev overrides with hot reload volume mounts"
      contains: "--reload"
    - path: "api/Dockerfile"
      provides: "Multi-stage Dockerfile for API service"
      contains: "uv"
    - path: ".env.example"
      provides: "Template for all environment variables"
      contains: "DATABASE_URL"
    - path: ".gitignore"
      provides: "Ignore patterns for Python, Docker, env files"
      contains: ".env"
  key_links:
    - from: "docker-compose.yml"
      to: ".env"
      via: "env_file directive"
      pattern: "env_file|environment"
    - from: "docker-compose.yml"
      to: "api/Dockerfile"
      via: "build context"
      pattern: "build.*context.*\\./api"
    - from: "docker-compose.override.yml"
      to: "docker-compose.yml"
      via: "Docker Compose automatic override merge"
      pattern: "services"
---

<objective>
Create the Docker Compose local development environment that boots PostgreSQL+pgvector, Redis, FastAPI API, and ARQ worker in one command.

Purpose: Every developer (and Claude) needs a working local environment to test schema, migrations, and fixtures. This plan creates the infrastructure that Plan 03 (Alembic + fixtures) will run against.

Output: `docker compose up -d` brings up all four services. PostgreSQL has pgvector extension available. API serves health check on port 8000.
</objective>

<execution_context>
@/home/bitnami/.claude/get-shit-done/workflows/execute-plan.md
@/home/bitnami/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-foundation/01-CONTEXT.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Docker Compose services and Dockerfile</name>
  <files>
    docker-compose.yml
    docker-compose.override.yml
    api/Dockerfile
    .dockerignore
  </files>
  <action>
Create the complete Docker Compose environment per user decision (PostgreSQL+pgvector, Redis, FastAPI app with hot reload, ARQ worker) and per research Pattern 6.

1. **`docker-compose.yml`** (base — all services):

   **postgres** service:
   - Image: `pgvector/pgvector:pg17` (per research recommendation — PG17 with pgvector pre-installed)
   - Environment: `POSTGRES_USER=commontrace`, `POSTGRES_PASSWORD=commontrace`, `POSTGRES_DB=commontrace`
   - Ports: `5432:5432`
   - Volume: `postgres_data:/var/lib/postgresql/data`
   - Healthcheck: `pg_isready -U commontrace`, interval 5s, timeout 5s, retries 5

   **redis** service:
   - Image: `redis:7-alpine`
   - Ports: `6379:6379`
   - Volume: `redis_data:/data`
   - Healthcheck: `redis-cli ping`, interval 5s, timeout 5s, retries 5

   **api** service:
   - Build context: `./api`
   - env_file: `.env`
   - Ports: `8000:8000`
   - depends_on: postgres (condition: service_healthy), redis (condition: service_healthy)
   - Command: `sh -c "alembic upgrade head && uvicorn app.main:app --host 0.0.0.0 --port 8000"` (runs migrations THEN starts app — per research guidance, never run migrations in FastAPI lifespan)

   **worker** service:
   - Build context: `./api` (same codebase as api)
   - env_file: `.env`
   - Command: `python -c "import asyncio; asyncio.run(asyncio.sleep(86400))"` (placeholder — real ARQ worker comes in Phase 3; this keeps the service alive so Docker Compose shows 4 services per user decision)
   - depends_on: postgres (condition: service_healthy), redis (condition: service_healthy)

   **volumes**: `postgres_data`, `redis_data`

2. **`docker-compose.override.yml`** (dev — loaded automatically by Docker Compose):

   **api** service overrides:
   - Command: `sh -c "alembic upgrade head && uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload"` (adds --reload for hot reloading)
   - Volume mount: `./api:/app` (source code mount for hot reload)

   **worker** service overrides:
   - Volume mount: `./api:/app` (source code mount)

3. **`api/Dockerfile`**:
   - Use `python:3.12-slim` as base
   - Install uv via `pip install uv` (or copy from official uv Docker image if available)
   - Set `WORKDIR /app`
   - Copy `pyproject.toml` first (for layer caching)
   - Run `uv sync --frozen --no-dev` for production deps
   - Copy `app/` directory
   - Copy `migrations/` directory (will exist after Plan 03)
   - Copy `alembic.ini` (will exist after Plan 03)
   - Default CMD: `uvicorn app.main:app --host 0.0.0.0 --port 8000`
   - NOTE: The Dockerfile should handle missing migrations/ and alembic.ini gracefully for now (Plan 01-03 creates them). Use `COPY migrations/ migrations/ 2>/dev/null || true` pattern, OR create placeholder empty directories.

   Actually, since Dockerfile COPY fails if source doesn't exist, create minimal placeholder files:
   - Create `api/alembic.ini` as empty placeholder (overwritten by Plan 03)
   - Create `api/migrations/` as empty dir with `.gitkeep`

   Better approach: Use a two-stage Dockerfile. Stage 1 installs deps. The COPY for migrations can be made optional by using a `.dockerignore` that doesn't exclude them and handling the case where they don't exist yet. Simplest: just have the Dockerfile copy everything and let Docker Compose override handle the volume mount in dev.

   Final approach for the Dockerfile:
   ```dockerfile
   FROM python:3.12-slim AS base
   RUN pip install uv
   WORKDIR /app
   COPY pyproject.toml .
   RUN uv sync --frozen --no-dev || uv sync --no-dev
   COPY . .
   CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
   ```
   Use `uv sync --frozen --no-dev || uv sync --no-dev` to handle case where lockfile doesn't exist yet (first build).

4. **`.dockerignore`**:
   ```
   __pycache__
   *.pyc
   .git
   .planning
   .env
   .venv
   *.egg-info
   ```
  </action>
  <verify>
Run `cd /home/bitnami/commontrace && docker compose config` to validate the compose files parse correctly (no syntax errors). Verify the output shows 4 services: postgres, redis, api, worker. Verify postgres uses `pgvector/pgvector:pg17` image.
  </verify>
  <done>docker-compose.yml defines all 4 services (postgres/pgvector, redis, api, worker). docker-compose.override.yml adds hot reload. Dockerfile builds API image. All compose config validates.</done>
</task>

<task type="auto">
  <name>Task 2: Environment configuration files</name>
  <files>
    .env.example
    .env
    .gitignore
  </files>
  <action>
1. **`.env.example`** — Template with all environment variables, documented:
   ```
   # Database
   DATABASE_URL=postgresql+asyncpg://commontrace:commontrace@localhost:5432/commontrace

   # Redis
   REDIS_URL=redis://localhost:6379

   # Application
   APP_NAME=CommonTrace
   DEBUG=true

   # Trust configuration (per user decision: configurable, not hardcoded)
   VALIDATION_THRESHOLD=2

   # Embedding (Phase 3 — pre-defined for schema compatibility)
   EMBEDDING_DIMENSIONS=1536
   ```

2. **`.env`** — Copy of .env.example with Docker-internal hostnames for Docker Compose:
   ```
   DATABASE_URL=postgresql+asyncpg://commontrace:commontrace@postgres:5432/commontrace
   REDIS_URL=redis://redis:6379
   APP_NAME=CommonTrace
   DEBUG=true
   VALIDATION_THRESHOLD=2
   EMBEDDING_DIMENSIONS=1536
   ```
   Note: Docker services use `postgres` and `redis` as hostnames (Docker Compose service names). The .env.example uses `localhost` for running outside Docker.

3. **`.gitignore`** — Comprehensive Python + Docker + project-specific ignores:
   ```
   # Python
   __pycache__/
   *.py[cod]
   *$py.class
   *.egg-info/
   dist/
   build/
   .venv/
   venv/

   # Environment
   .env
   !.env.example

   # IDE
   .idea/
   .vscode/
   *.swp
   *.swo

   # Docker
   postgres_data/

   # OS
   .DS_Store
   Thumbs.db

   # Testing
   .coverage
   htmlcov/
   .pytest_cache/

   # uv
   .uv/

   # Planning docs are tracked (per user decision)
   # .planning/ is NOT ignored
   ```

   IMPORTANT: `.env` is gitignored (contains secrets in production). `.env.example` is NOT ignored (template for developers). `.planning/` is NOT ignored (lives at repo root per user decision).
  </action>
  <verify>
Verify `.env.example` exists and contains DATABASE_URL, REDIS_URL, VALIDATION_THRESHOLD. Verify `.env` exists with Docker-internal hostnames (postgres, redis instead of localhost). Verify `.gitignore` includes `.env` but not `.env.example` and not `.planning/`.
  </verify>
  <done>.env.example provides template for all env vars. .env has Docker-internal hostnames for compose. .gitignore covers Python, Docker, IDE, env files. VALIDATION_THRESHOLD is configurable via env var (not hardcoded).</done>
</task>

</tasks>

<verification>
1. `docker compose config` validates without errors and shows 4 services
2. postgres service uses `pgvector/pgvector:pg17` image
3. api service depends on postgres (service_healthy) and redis (service_healthy)
4. worker service depends on postgres and redis
5. .env has Docker-internal hostnames (postgres, redis)
6. .env.example has localhost hostnames for local dev
7. .gitignore includes .env but NOT .env.example and NOT .planning/
8. api/Dockerfile exists and uses python:3.12-slim
</verification>

<success_criteria>
- `docker compose config` shows postgres, redis, api, worker services
- postgres uses pgvector/pgvector:pg17 image
- .env, .env.example, .gitignore all exist with correct content
- Dockerfile builds from python:3.12-slim with uv
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-02-SUMMARY.md`
</output>
