---
phase: 02-core-api
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - api/app/routers/__init__.py
  - api/app/routers/auth.py
  - api/app/routers/traces.py
  - api/app/routers/votes.py
  - api/app/routers/amendments.py
  - api/app/main.py
autonomous: true

must_haves:
  truths:
    - "An agent can submit a new trace and receive 202 Accepted with trace ID in pending state"
    - "Submitting a trace containing a secret is rejected with 422 before database write"
    - "An agent can upvote a trace; the vote is recorded with voter identity"
    - "An agent can downvote a trace with a contextual tag; downvote without tag is rejected"
    - "An agent can submit an amendment to an existing trace with improved solution and explanation"
    - "A new API key can be generated via POST /api/v1/keys; the raw key is returned once and only the hash is stored"
    - "Double-voting on the same trace returns 409 Conflict"
  artifacts:
    - path: "api/app/routers/traces.py"
      provides: "POST /api/v1/traces endpoint"
      contains: "submit_trace"
    - path: "api/app/routers/votes.py"
      provides: "POST /api/v1/traces/{id}/votes endpoint"
      contains: "cast_vote"
    - path: "api/app/routers/amendments.py"
      provides: "POST /api/v1/traces/{id}/amendments endpoint"
      contains: "submit_amendment"
    - path: "api/app/routers/auth.py"
      provides: "POST /api/v1/keys endpoint"
      contains: "generate_api_key"
    - path: "api/app/main.py"
      provides: "Router registration"
      contains: "include_router"
  key_links:
    - from: "api/app/routers/traces.py"
      to: "api/app/services/scanner.py"
      via: "scan_trace_submission called before db.add"
      pattern: "scan_trace_submission"
    - from: "api/app/routers/traces.py"
      to: "api/app/services/staleness.py"
      via: "check_trace_staleness on metadata_json"
      pattern: "check_trace_staleness"
    - from: "api/app/routers/votes.py"
      to: "api/app/services/trust.py"
      via: "apply_vote_to_trace after vote insert"
      pattern: "apply_vote_to_trace"
    - from: "api/app/routers/votes.py"
      to: "sqlalchemy.exc.IntegrityError"
      via: "catch duplicate vote UniqueConstraint"
      pattern: "IntegrityError"
    - from: "api/app/main.py"
      to: "api/app/routers/*.py"
      via: "app.include_router for all routers"
      pattern: "include_router"
---

<objective>
Wire all write-path API endpoints: API key generation, trace submission, voting, and amendments -- each protected by authentication, rate limiting, and PII scanning.

Purpose: This is where the safety gates (auth, rate limit, PII scan) meet the business logic (create trace, cast vote, submit amendment). Every write goes through the three-gate chain: authenticate -> rate limit -> scan -> process. This plan delivers requirements CONT-01, CONT-02, CONT-04, API-01, and API-02.

Output: Four router modules (auth, traces, votes, amendments) registered on the FastAPI app, fully wired with dependencies from Plans 02-01 and 02-02.
</objective>

<execution_context>
@/home/bitnami/.claude/get-shit-done/workflows/execute-plan.md
@/home/bitnami/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-api/02-RESEARCH.md
@.planning/phases/02-core-api/02-01-SUMMARY.md
@.planning/phases/02-core-api/02-02-SUMMARY.md

@api/app/dependencies.py
@api/app/main.py
@api/app/models/trace.py
@api/app/models/vote.py
@api/app/models/user.py
@api/app/models/amendment.py
@api/app/models/tag.py
@api/app/services/scanner.py
@api/app/services/staleness.py
@api/app/services/trust.py
@api/app/services/tags.py
@api/app/schemas/trace.py
@api/app/schemas/vote.py
@api/app/schemas/amendment.py
@api/app/schemas/auth.py
@api/app/middleware/rate_limiter.py
@api/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Auth router and trace submission endpoint</name>
  <files>
    api/app/routers/__init__.py
    api/app/routers/auth.py
    api/app/routers/traces.py
  </files>
  <action>
1. Create api/app/routers/__init__.py (empty file).

2. Create api/app/routers/auth.py -- API key generation:
   - APIRouter with prefix="/api/v1", tags=["auth"]
   - POST /keys endpoint (NO authentication required -- this IS how you get a key):
     - Accepts APIKeyCreate body (email, display_name)
     - Generates raw key: `secrets.token_urlsafe(32)`
     - Computes hash: `hashlib.sha256(raw_key.encode()).hexdigest()`
     - Creates User row with api_key_hash, email (optional), display_name (optional)
     - If email is provided and already exists: raise HTTPException(409, "Email already registered")
     - Catch IntegrityError on api_key_hash collision (astronomically unlikely but handle it): retry once with new key
     - Returns APIKeyResponse with raw key, user_id, and warning message
     - The raw key is NEVER stored -- only the hash
     - `await db.commit()` after creating user
   - GET /keys/verify endpoint (requires CurrentUser auth):
     - Simple endpoint that returns {"valid": True, "user_id": str(user.id)} -- for testing auth

3. Create api/app/routers/traces.py -- trace submission:
   - APIRouter with prefix="/api/v1", tags=["traces"]
   - POST /traces endpoint (status_code=202):
     - Dependencies: CurrentUser, DbSession, WriteRateLimit (from rate_limiter)
     - Accepts TraceCreate body
     - Gate 1: Auth -- handled by CurrentUser dependency
     - Gate 2: Rate limit -- handled by WriteRateLimit dependency
     - Gate 3: PII scan -- call `scan_trace_submission(body.title, body.context_text, body.solution_text)`. Catch SecretDetectedError and raise HTTPException(422, f"Content rejected: {e}")
     - Tag processing: normalize each tag via normalize_tag(), validate via validate_tag(), get-or-create Tag rows. Use `select(Tag).where(Tag.name == normalized)` then create if not found. Associate via trace_tags insert (same pattern as seed fixtures -- direct insert, not relationship.append).
     - Create Trace row: status="pending", contributor_id=user.id, all fields from body
     - Staleness check: call `await check_trace_staleness(body.metadata_json)` -- if True, set is_stale=True on the trace
     - `await db.commit()`, `await db.refresh(trace)`
     - Return TraceAccepted(id=trace.id, status="pending")
   - GET /traces/{trace_id} endpoint:
     - Dependencies: CurrentUser, DbSession, ReadRateLimit
     - Fetch trace by ID with `selectinload(Trace.tags)` to avoid MissingGreenlet
     - If not found: HTTPException(404, "Trace not found")
     - Serialize tags to list of tag name strings for the response
     - Return TraceResponse
  </action>
  <verify>
    cd /home/bitnami/commontrace && python -c "
from app.routers.auth import router as auth_router
from app.routers.traces import router as traces_router
print(f'Auth routes: {[r.path for r in auth_router.routes]}')
print(f'Trace routes: {[r.path for r in traces_router.routes]}')
# Verify route methods
for r in auth_router.routes:
    if hasattr(r, 'methods'):
        print(f'  {r.path}: {r.methods}')
for r in traces_router.routes:
    if hasattr(r, 'methods'):
        print(f'  {r.path}: {r.methods}')
"
  </verify>
  <done>
    - POST /api/v1/keys generates API key, stores hash, returns raw key once
    - GET /api/v1/keys/verify confirms auth is working
    - POST /api/v1/traces accepts trace with PII scanning gate, returns 202
    - GET /api/v1/traces/{id} returns trace with tags
    - All endpoints protected by appropriate auth + rate limit dependencies
  </done>
</task>

<task type="auto">
  <name>Task 2: Vote and amendment endpoints, router registration</name>
  <files>
    api/app/routers/votes.py
    api/app/routers/amendments.py
    api/app/main.py
  </files>
  <action>
1. Create api/app/routers/votes.py -- voting:
   - APIRouter with prefix="/api/v1", tags=["votes"]
   - POST /traces/{trace_id}/votes endpoint:
     - Dependencies: CurrentUser, DbSession, WriteRateLimit
     - Accepts VoteCreate body (already validates downvote requires tag via model_validator)
     - Verify trace exists: `select(Trace).where(Trace.id == trace_id)`. If not found: HTTPException(404)
     - Prevent self-vote: if trace.contributor_id == user.id: HTTPException(403, "Cannot vote on your own trace")
     - Create Vote row: trace_id, voter_id=user.id, vote_type=body.vote_type, feedback_text=body.feedback_text, context_json={"feedback_tag": body.feedback_tag} if feedback_tag provided
     - Wrap db.add + db.flush in try/except for IntegrityError:
       - Catch `sqlalchemy.exc.IntegrityError` -- check if constraint is `uq_votes_trace_id_voter_id`
       - If so: `await db.rollback()` and raise HTTPException(409, "Already voted on this trace")
       - Otherwise: re-raise
     - After successful vote insert: call `await apply_vote_to_trace(db, trace_id, user.reputation_score, is_upvote=(body.vote_type == "up"))`
     - `await db.commit()`, `await db.refresh(vote)`
     - Return VoteResponse (201)

2. Create api/app/routers/amendments.py -- amendments:
   - APIRouter with prefix="/api/v1", tags=["amendments"]
   - POST /traces/{trace_id}/amendments endpoint:
     - Dependencies: CurrentUser, DbSession, WriteRateLimit
     - Accepts AmendmentCreate body
     - Verify trace exists: HTTPException(404) if not
     - PII scan: call `scan_amendment_submission(body.improved_solution, body.explanation)`. Catch SecretDetectedError -> HTTPException(422)
     - Create Amendment row: original_trace_id=trace_id, submitter_id=user.id, improved_solution, explanation
     - `await db.commit()`, `await db.refresh(amendment)`
     - Return AmendmentResponse (201)

3. Update api/app/main.py to register all routers:
   - Import all four routers from app.routers (auth, traces, votes, amendments)
   - Call `app.include_router(router)` for each
   - Keep existing lifespan and health check from Plan 02-01
   - Do NOT modify any other existing code in main.py
  </action>
  <verify>
    cd /home/bitnami/commontrace && python -c "
from app.main import app

# List all registered routes
routes = []
for route in app.routes:
    if hasattr(route, 'methods') and hasattr(route, 'path'):
        routes.append(f'{route.methods} {route.path}')
routes.sort()
for r in routes:
    print(r)

# Verify expected endpoints exist
expected = ['/api/v1/keys', '/api/v1/traces', '/api/v1/traces/{trace_id}', '/api/v1/traces/{trace_id}/votes', '/api/v1/traces/{trace_id}/amendments']
registered_paths = [r.path for r in app.routes if hasattr(r, 'path')]
for ep in expected:
    found = ep in registered_paths
    print(f'  {ep}: {\"OK\" if found else \"MISSING\"}'  )
"
  </verify>
  <done>
    - POST /api/v1/traces/{id}/votes records vote with contextual feedback
    - Double-vote returns 409 Conflict (IntegrityError caught)
    - Self-vote returns 403 Forbidden
    - Vote triggers trust score update and potential promotion
    - POST /api/v1/traces/{id}/amendments creates amendment with PII scanning
    - All routers registered on FastAPI app
    - All endpoints visible in OpenAPI docs (/docs)
  </done>
</task>

</tasks>

<verification>
1. `python -c "from app.main import app; print(len(list(app.routes)))"` shows all routes registered
2. Routes include: POST /keys, GET /keys/verify, POST /traces, GET /traces/{id}, POST /traces/{id}/votes, POST /traces/{id}/amendments
3. All POST endpoints require CurrentUser (401 without API key)
4. POST /keys does NOT require authentication
5. Vote endpoint catches IntegrityError for duplicate votes
6. Trace endpoint calls scan_trace_submission before db.add
</verification>

<success_criteria>
- API key generation works: POST /keys returns raw key, stores only hash (API-01)
- Trace submission with PII scan gate: 202 on clean content, 422 on secrets (API-02, CONT-01)
- Voting with contextual feedback: upvote/downvote recorded, duplicate prevented (CONT-02)
- Amendment submission with PII scan: 201 on clean content (CONT-04)
- All endpoints rate-limited via WriteRateLimit dependency
- All routes registered and visible in OpenAPI schema
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-api/02-03-SUMMARY.md`
</output>
