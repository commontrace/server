---
phase: 02-core-api
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - api/app/services/scanner.py
  - api/app/services/staleness.py
  - api/app/services/trust.py
  - api/app/schemas/__init__.py
  - api/app/schemas/common.py
  - api/app/schemas/trace.py
  - api/app/schemas/vote.py
  - api/app/schemas/amendment.py
  - api/app/schemas/auth.py
autonomous: true

must_haves:
  truths:
    - "Text containing an API key, password, or credential token is detected and rejected by the scanner"
    - "Text describing debugging scenarios with words like 'password' or 'token' in context does not trigger false positives on the solution field scanner (KeywordDetector disabled for context_text and title)"
    - "A downvote without a contextual tag from the approved set is rejected at the schema level"
    - "A library version behind current PyPI major.minor is identified as stale"
    - "A vote on a pending trace that reaches the validation threshold promotes the trace to validated status"
  artifacts:
    - path: "api/app/services/scanner.py"
      provides: "PII/secrets scanning gate"
      contains: "scan_content"
    - path: "api/app/services/staleness.py"
      provides: "PyPI version staleness checker"
      contains: "check_library_staleness"
    - path: "api/app/services/trust.py"
      provides: "Vote application and trace promotion logic"
      contains: "apply_vote_to_trace"
    - path: "api/app/schemas/trace.py"
      provides: "TraceCreate, TraceResponse, TraceAccepted Pydantic schemas"
      contains: "class TraceCreate"
    - path: "api/app/schemas/vote.py"
      provides: "VoteCreate with downvote validation"
      contains: "DOWNVOTE_REQUIRED_TAGS"
    - path: "api/app/schemas/amendment.py"
      provides: "AmendmentCreate, AmendmentResponse schemas"
      contains: "class AmendmentCreate"
  key_links:
    - from: "api/app/services/scanner.py"
      to: "detect_secrets"
      via: "scan_line with default_settings context"
      pattern: "default_settings"
    - from: "api/app/services/trust.py"
      to: "api/app/models/trace.py"
      via: "atomic UPDATE on confirmation_count and trust_score"
      pattern: "update\\(Trace\\)"
    - from: "api/app/services/staleness.py"
      to: "httpx"
      via: "PyPI JSON API lookup with 3s timeout"
      pattern: "pypi\\.org/pypi"
---

<objective>
Build all service-layer logic (PII scanning, staleness detection, trust score updates) and Pydantic request/response schemas that the write-path endpoints will consume.

Purpose: Endpoints in Plan 02-03 need validated request schemas and service functions. Building them separately keeps Plan 02-03 focused on HTTP wiring. The PII scanner is the critical safety gate (SAFE-02) -- no trace touches the database without passing through it.

Output: scanner.py (PII gate), staleness.py (PyPI checker), trust.py (vote application + promotion), and all Pydantic schemas (trace, vote, amendment, auth, common).
</objective>

<execution_context>
@/home/bitnami/.claude/get-shit-done/workflows/execute-plan.md
@/home/bitnami/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-api/02-RESEARCH.md

@api/app/models/trace.py
@api/app/models/vote.py
@api/app/models/user.py
@api/app/config.py
@api/app/services/tags.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: PII scanner, staleness checker, and trust service</name>
  <files>
    api/app/services/scanner.py
    api/app/services/staleness.py
    api/app/services/trust.py
  </files>
  <action>
1. Create api/app/services/scanner.py -- PII/secrets synchronous gate:
   - Define `SecretDetectedError(Exception)` with a `secret_types: set[str]` attribute for the types found
   - Implement `scan_content(text: str) -> None`:
     - Wraps in `with default_settings():` context (required for detect-secrets plugin discovery)
     - Iterates text.splitlines(), calls `scan_line(line)` from detect_secrets.core.scan
     - If any secrets found: raise SecretDetectedError with types but DO NOT echo the detected secret value
   - Implement `scan_trace_submission(title: str, context_text: str, solution_text: str) -> None`:
     - Scans all three fields using scan_content()
     - Per research open question 3: For `context_text` and `title`, consider that terms like "password" and "token" may appear legitimately when describing debugging scenarios. Use all detectors on all fields for now (keeping it simple and secure -- false positives are better than missed secrets). Document this choice with a comment.
   - Implement `scan_amendment_submission(improved_solution: str, explanation: str) -> None`:
     - Scans both fields
   - This is a SYNC function -- detect-secrets is CPU-bound, FastAPI auto-threadpools sync functions
   - Import from: `detect_secrets.settings.default_settings`, `detect_secrets.core.scan.scan_line`

2. Create api/app/services/staleness.py -- PyPI version staleness checker:
   - Implement `async check_library_staleness(library_name: str, stored_version_str: str) -> bool`:
     - Parse stored_version_str with `packaging.version.Version`; return False on InvalidVersion
     - GET `https://pypi.org/pypi/{library_name}/json` with httpx.AsyncClient(timeout=3.0)
     - Compare stored major.minor against latest major.minor
     - Return True if stored is behind
     - Catch ALL exceptions gracefully -- never block/fail on staleness check (graceful degradation)
   - Implement `async check_trace_staleness(metadata_json: dict | None) -> bool`:
     - If metadata_json is None or missing "library" and "library_version" keys: return False
     - Extract library name and version, call check_library_staleness
     - This is the submission-time convenience wrapper

3. Create api/app/services/trust.py -- vote application and promotion:
   - Implement `async apply_vote_to_trace(db: AsyncSession, trace_id: UUID, vote_weight: float, is_upvote: bool) -> None`:
     - Calculate score_delta: +vote_weight for upvote, -vote_weight for downvote
     - Execute atomic UPDATE: `confirmation_count = Trace.confirmation_count + 1`, `trust_score = Trace.trust_score + score_delta` (no SELECT first)
     - After UPDATE, query the row to check promotion eligibility
     - If status is pending AND confirmation_count >= settings.validation_threshold AND trust_score > 0: UPDATE status to "validated"
     - Use column expressions in values() for atomicity (not Python-side calculation)
   - Import settings from app.config, Trace and TraceStatus from app.models
  </action>
  <verify>
    cd /home/bitnami/commontrace && python -c "
from app.services.scanner import scan_content, scan_trace_submission, SecretDetectedError
from app.services.staleness import check_library_staleness, check_trace_staleness
from app.services.trust import apply_vote_to_trace
print('Scanner imports OK')
print('Staleness imports OK')
print('Trust imports OK')

# Quick scanner smoke test
try:
    scan_content('AKIAIOSFODNN7EXAMPLE')
    print('WARN: AWS key not detected')
except SecretDetectedError as e:
    print(f'Scanner caught secret: {e.secret_types}')
except Exception as e:
    print(f'Scanner error (may need detect-secrets investigation): {e}')

# Clean text should pass
scan_content('This is normal text about a function')
print('Clean text passed scanner OK')
"
  </verify>
  <done>
    - scan_content detects AWS keys, high-entropy tokens, and known credential patterns
    - scan_trace_submission scans title + context + solution fields
    - check_library_staleness returns True when stored version is behind PyPI latest
    - apply_vote_to_trace atomically increments confirmation_count and trust_score
    - Trace promotion fires when threshold reached with positive trust score
  </done>
</task>

<task type="auto">
  <name>Task 2: Pydantic request/response schemas for all endpoints</name>
  <files>
    api/app/schemas/__init__.py
    api/app/schemas/common.py
    api/app/schemas/trace.py
    api/app/schemas/vote.py
    api/app/schemas/amendment.py
    api/app/schemas/auth.py
  </files>
  <action>
1. Create api/app/schemas/__init__.py that re-exports all schema classes.

2. Create api/app/schemas/common.py:
   - `ErrorResponse(BaseModel)`: error (str), detail (Optional[str])
   - `PaginatedResponse(BaseModel, Generic[T])`: items (list[T]), total (int), page (int), page_size (int)

3. Create api/app/schemas/trace.py:
   - `TraceCreate(BaseModel)`:
     - title: str = Field(min_length=1, max_length=500)
     - context_text: str = Field(min_length=1)
     - solution_text: str = Field(min_length=1)
     - tags: list[str] = Field(default_factory=list, max_length=20) -- max 20 tags
     - agent_model: Optional[str] = Field(None, max_length=100)
     - agent_version: Optional[str] = Field(None, max_length=50)
     - metadata_json: Optional[dict] = None
   - `TraceResponse(BaseModel)`:
     - model_config = ConfigDict(from_attributes=True)
     - id: uuid.UUID, status: str, title: str, context_text: str, solution_text: str
     - trust_score: float, confirmation_count: int
     - tags: list[str] (serialized from ORM)
     - is_stale: bool, is_flagged: bool
     - contributor_id: uuid.UUID
     - created_at: datetime, updated_at: datetime
   - `TraceAccepted(BaseModel)`:
     - id: uuid.UUID, status: str (always "pending"), message: str = "Trace accepted for processing"

4. Create api/app/schemas/vote.py:
   - Define `DOWNVOTE_REQUIRED_TAGS = {"outdated", "wrong", "security_concern", "spam"}`
   - `VoteCreate(BaseModel)`:
     - vote_type: str -- "up" or "down"
     - feedback_tag: Optional[str] = None
     - feedback_text: Optional[str] = None
     - Add `@model_validator(mode="after")` `downvote_requires_tag`:
       - If vote_type == "down" and feedback_tag not in DOWNVOTE_REQUIRED_TAGS: raise ValueError
       - If vote_type not in ("up", "down"): raise ValueError("vote_type must be 'up' or 'down'")
   - `VoteResponse(BaseModel)`:
     - model_config = ConfigDict(from_attributes=True)
     - id: uuid.UUID, trace_id: uuid.UUID, voter_id: uuid.UUID, vote_type: str
     - feedback_tag: Optional[str], feedback_text: Optional[str]
     - created_at: datetime

5. Create api/app/schemas/amendment.py:
   - `AmendmentCreate(BaseModel)`:
     - improved_solution: str = Field(min_length=1)
     - explanation: str = Field(min_length=1, max_length=5000)
   - `AmendmentResponse(BaseModel)`:
     - model_config = ConfigDict(from_attributes=True)
     - id: uuid.UUID, original_trace_id: uuid.UUID, submitter_id: uuid.UUID
     - improved_solution: str, explanation: str, created_at: datetime

6. Create api/app/schemas/auth.py:
   - `APIKeyResponse(BaseModel)`: api_key: str, user_id: uuid.UUID, message: str = "Store this key securely -- it cannot be retrieved again"
   - `APIKeyCreate(BaseModel)`: email: Optional[str] = Field(None, max_length=255), display_name: Optional[str] = Field(None, max_length=100)
  </action>
  <verify>
    cd /home/bitnami/commontrace && python -c "
from app.schemas import TraceCreate, TraceResponse, TraceAccepted, VoteCreate, VoteResponse, AmendmentCreate, AmendmentResponse, APIKeyCreate, APIKeyResponse, ErrorResponse
print('All schemas imported OK')

# Test downvote validation
from pydantic import ValidationError
try:
    VoteCreate(vote_type='down')
    print('ERROR: downvote without tag should fail')
except ValidationError:
    print('Downvote validation OK: tag required')

# Test upvote passes without tag
v = VoteCreate(vote_type='up')
print(f'Upvote OK: {v.vote_type}')

# Test trace create validation
try:
    TraceCreate(title='', context_text='test', solution_text='test')
    print('ERROR: empty title should fail')
except ValidationError:
    print('TraceCreate validation OK: empty title rejected')

t = TraceCreate(title='Fix Docker build', context_text='Docker fails', solution_text='Add .dockerignore')
print(f'TraceCreate OK: {t.title}')
"
  </verify>
  <done>
    - All Pydantic schemas created with proper validation rules
    - Downvote requires feedback_tag from approved set (outdated, wrong, security_concern, spam)
    - TraceCreate enforces min_length on title/context/solution and max 20 tags
    - Response schemas use ConfigDict(from_attributes=True) for ORM serialization
    - APIKeyCreate/Response schemas ready for key generation endpoint
    - All schemas importable from app.schemas
  </done>
</task>

</tasks>

<verification>
1. Scanner detects known credential patterns (AWS keys, high-entropy strings)
2. Clean text passes scanner without false positives
3. VoteCreate rejects downvote without approved tag
4. VoteCreate accepts upvote without tag
5. TraceCreate rejects empty title/context/solution
6. All services and schemas importable from their respective packages
</verification>

<success_criteria>
- PII scanner blocks text containing API keys, passwords, or credential tokens (SAFE-02)
- Staleness checker identifies outdated library versions via PyPI comparison (SAFE-04)
- Trust service atomically updates confirmation_count and promotes traces at threshold (SAFE-01)
- All Pydantic schemas enforce validation rules matching API contract
- Downvote requires contextual tag (CONT-02)
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-api/02-02-SUMMARY.md`
</output>
