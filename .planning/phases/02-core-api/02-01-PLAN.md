---
phase: 02-core-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/pyproject.toml
  - api/app/config.py
  - api/app/main.py
  - api/app/dependencies.py
  - api/app/middleware/__init__.py
  - api/app/middleware/rate_limiter.py
  - api/app/models/amendment.py
  - api/app/models/__init__.py
  - api/migrations/versions/0002_amendments_and_staleness.py
autonomous: true

must_haves:
  truths:
    - "An API request without a valid API key is rejected with 401"
    - "A valid API key grants access; the authenticated User object is available in endpoint handlers"
    - "A user exceeding the per-key rate limit receives 429 with Retry-After header"
    - "Read and write endpoints have separate rate limit capacities"
    - "The amendments table and staleness columns exist in the database after migration"
  artifacts:
    - path: "api/app/dependencies.py"
      provides: "CurrentUser auth dependency, RedisClient dependency"
      contains: "get_current_user"
    - path: "api/app/middleware/rate_limiter.py"
      provides: "Token bucket rate limiter via Redis Lua script"
      contains: "RATE_LIMIT_LUA"
    - path: "api/app/main.py"
      provides: "FastAPI app with Redis lifespan"
      contains: "lifespan"
    - path: "api/app/models/amendment.py"
      provides: "Amendment ORM model"
      contains: "class Amendment"
    - path: "api/migrations/versions/0002_amendments_and_staleness.py"
      provides: "Alembic migration for amendments table + is_stale/is_flagged columns"
      contains: "create_table"
  key_links:
    - from: "api/app/dependencies.py"
      to: "api/app/models/user.py"
      via: "SHA-256 hash lookup on users.api_key_hash"
      pattern: "hashlib\\.sha256"
    - from: "api/app/middleware/rate_limiter.py"
      to: "api/app/dependencies.py"
      via: "RedisClient dependency injection"
      pattern: "RedisClient"
    - from: "api/app/main.py"
      to: "redis.asyncio"
      via: "lifespan context manager stores Redis on app.state"
      pattern: "app\\.state\\.redis"
---

<objective>
Build the authentication, rate limiting, and schema infrastructure that all Phase 2 write endpoints depend on.

Purpose: Every write-path endpoint in Phase 2 needs three things: an authenticated user (API key -> User lookup), rate limiting (Redis token bucket), and the new database schema (amendments table, staleness columns). This plan creates all three foundations.

Output: CurrentUser dependency, RedisClient dependency, Lua token-bucket rate limiter, Amendment model, Alembic migration 0002, extended config with rate limit settings.
</objective>

<execution_context>
@/home/bitnami/.claude/get-shit-done/workflows/execute-plan.md
@/home/bitnami/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-api/02-RESEARCH.md
@.planning/phases/01-data-foundation/01-01-SUMMARY.md

@api/app/config.py
@api/app/main.py
@api/app/dependencies.py
@api/app/database.py
@api/app/models/base.py
@api/app/models/user.py
@api/app/models/trace.py
@api/app/models/__init__.py
@api/pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies, extend config, add Amendment model and migration</name>
  <files>
    api/pyproject.toml
    api/app/config.py
    api/app/models/amendment.py
    api/app/models/__init__.py
    api/migrations/versions/0002_amendments_and_staleness.py
  </files>
  <action>
1. Add new dependencies to api/pyproject.toml:
   - `"redis[asyncio]>=5.0"` (async Redis client — aioredis merged into redis-py)
   - `"detect-secrets>=1.5.0"` (PII/secrets scanning)
   - `"packaging>=23.0"` (PEP 440 version parsing for staleness)
   - `"httpx>=0.27"` (move from dev to main deps — needed for PyPI staleness check)
   Run `cd /home/bitnami/commontrace && uv sync` after editing.

2. Extend api/app/config.py Settings class with rate limit settings:
   - `rate_limit_read_per_minute: int = 60` (token bucket capacity for reads)
   - `rate_limit_write_per_minute: int = 20` (token bucket capacity for writes)
   - `api_key_header_name: str = "X-API-Key"` (configurable header name)

3. Create api/app/models/amendment.py with the Amendment ORM model:
   - Columns: id (UUID PK), original_trace_id (FK traces.id, indexed), submitter_id (FK users.id), improved_solution (Text), explanation (Text), created_at (DateTime tz, server_default now)
   - Relationships: original_trace (Trace, lazy="raise"), submitter (User, lazy="raise") — use TYPE_CHECKING imports
   - Follow exact patterns from existing models: UUID(as_uuid=True), mapped_column(), Mapped[] type hints
   - Use named ForeignKey constraints: `name="fk_amendments_original_trace_id_traces"` and `name="fk_amendments_submitter_id_users"`

4. Update api/app/models/__init__.py to export Amendment.

5. Create manual Alembic migration api/migrations/versions/0002_amendments_and_staleness.py:
   - Revision ID: `c3d4e5f6a7b8`
   - Revises: `b2c3d4e5f6a7` (0001_initial_schema)
   - Add columns to traces table: `is_stale` (Boolean, NOT NULL, server_default false), `is_flagged` (Boolean, NOT NULL, server_default false), `flagged_at` (DateTime tz, nullable)
   - Create indexes: `ix_traces_is_flagged` on traces.is_flagged, `ix_traces_is_stale` on traces.is_stale
   - Create amendments table with all columns matching the ORM model
   - Create indexes: `ix_amendments_original_trace_id`, `ix_amendments_submitter_id`
   - Write proper downgrade() that drops in reverse order
   - Do NOT use autogenerate — write manually (same pattern as existing migrations)
  </action>
  <verify>
    cd /home/bitnami/commontrace && uv sync && python -c "from app.models import Amendment; print('Amendment model OK')" && python -c "from app.config import settings; print(f'Rate limits: {settings.rate_limit_read_per_minute}r/{settings.rate_limit_write_per_minute}w')"
  </verify>
  <done>
    - New dependencies installed (redis, detect-secrets, packaging, httpx)
    - Settings has rate_limit_read_per_minute=60 and rate_limit_write_per_minute=20
    - Amendment model importable from app.models
    - Migration 0002 exists with amendments table and staleness columns
  </done>
</task>

<task type="auto">
  <name>Task 2: Redis lifespan, auth dependency, and rate limiter</name>
  <files>
    api/app/main.py
    api/app/dependencies.py
    api/app/middleware/__init__.py
    api/app/middleware/rate_limiter.py
  </files>
  <action>
1. Rewrite api/app/main.py to use FastAPI lifespan context manager:
   - Import `redis.asyncio as aioredis` and `asynccontextmanager` from contextlib
   - Create `lifespan(app)` that:
     - On startup: creates Redis connection via `aioredis.from_url(settings.redis_url, encoding="utf-8", decode_responses=True)` and stores on `app.state.redis`
     - On shutdown: calls `await app.state.redis.aclose()`
   - Pass `lifespan=lifespan` to FastAPI constructor
   - Keep existing health check endpoint
   - Do NOT register routers yet (that's Plan 02-03)

2. Extend api/app/dependencies.py with three new dependencies:
   a. `get_redis(request: Request) -> aioredis.Redis` — returns `request.app.state.redis`
   b. `get_current_user(raw_key, db)` — extracts API key from X-API-Key header via `APIKeyHeader(name="X-API-Key", auto_error=True)`, computes `hashlib.sha256(raw_key.encode()).hexdigest()`, queries `select(User).where(User.api_key_hash == key_hash)`. Returns User or raises HTTPException(401, "Invalid API key"). Do NOT distinguish missing vs invalid key in error.
   c. Type aliases: `CurrentUser = Annotated[User, Depends(get_current_user)]` and `RedisClient = Annotated[aioredis.Redis, Depends(get_redis)]`
   - Keep existing DbSession alias
   - Use `Security(api_key_header)` for the raw_key parameter (registers in OpenAPI security scheme)

3. Create api/app/middleware/__init__.py (empty).

4. Create api/app/middleware/rate_limiter.py:
   - Define RATE_LIMIT_LUA Lua script implementing token bucket: HGETALL for current tokens + last_refill, calculate elapsed time, refill tokens up to max, consume 1 if available, HSET updated values, EXPIRE key
   - Create `check_rate_limit(user, redis_client, bucket_type, settings)` async function:
     - bucket_type is "read" or "write"
     - Key format: `rl:{user.id}:{bucket_type}`
     - Read max_tokens from settings (rate_limit_read_per_minute or rate_limit_write_per_minute)
     - Calculate refill_rate as max_tokens / 60.0 (tokens per second)
     - Call `redis_client.eval(RATE_LIMIT_LUA, 1, key, max_tokens, refill_rate, time.time())`
     - If not allowed: raise HTTPException(429, "Rate limit exceeded", headers={"Retry-After": "60"})
   - Create FastAPI dependency factories:
     - `require_read_limit()` returns a Depends-compatible callable that calls check_rate_limit with bucket_type="read"
     - `require_write_limit()` returns a Depends-compatible callable that calls check_rate_limit with bucket_type="write"
   - Export type aliases: `ReadRateLimit` and `WriteRateLimit` as Annotated types for clean endpoint signatures
  </action>
  <verify>
    cd /home/bitnami/commontrace && python -c "
from app.main import app
from app.dependencies import CurrentUser, RedisClient, DbSession
from app.middleware.rate_limiter import ReadRateLimit, WriteRateLimit, RATE_LIMIT_LUA
print('App lifespan:', hasattr(app, 'router'))
print('Dependencies OK: CurrentUser, RedisClient, DbSession')
print('Rate limiter OK: Lua script length =', len(RATE_LIMIT_LUA))
print('All imports successful')
"
  </verify>
  <done>
    - FastAPI app uses lifespan to create/destroy Redis connection on app.state
    - CurrentUser dependency authenticates via X-API-Key header with SHA-256 hash lookup
    - RedisClient dependency injects Redis from app.state
    - Rate limiter uses Lua token bucket with separate read/write capacities
    - ReadRateLimit and WriteRateLimit Annotated types ready for endpoint injection
  </done>
</task>

</tasks>

<verification>
1. All new files importable without errors: `python -c "from app.models import Amendment; from app.dependencies import CurrentUser, RedisClient; from app.middleware.rate_limiter import ReadRateLimit, WriteRateLimit"`
2. Migration file has proper revision chain: revises b2c3d4e5f6a7
3. Settings loads rate limit values from env: `python -c "from app.config import settings; assert settings.rate_limit_read_per_minute == 60"`
4. RATE_LIMIT_LUA script is valid Lua (has KEYS[1], ARGV[1-3], returns 0 or 1)
</verification>

<success_criteria>
- API key authentication dependency exists and performs SHA-256 hash lookup against users table
- Redis lifespan manages connection lifecycle on app.state
- Token bucket rate limiter has separate read/write capacities with Lua atomicity
- Amendment ORM model follows existing codebase patterns (UUID PK, mapped_column, named FKs)
- Migration 0002 adds amendments table + is_stale/is_flagged/flagged_at to traces
- All new dependencies installed (redis[asyncio], detect-secrets, packaging, httpx)
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-api/02-01-SUMMARY.md`
</output>
