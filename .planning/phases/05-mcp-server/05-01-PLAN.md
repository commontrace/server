---
phase: 05-mcp-server
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mcp-server/pyproject.toml
  - mcp-server/app/__init__.py
  - mcp-server/app/config.py
  - mcp-server/app/backend_client.py
  - mcp-server/app/formatters.py
  - mcp-server/app/server.py
  - mcp-server/app/__main__.py
  - mcp-server/Dockerfile
  - api/app/routers/tags.py
  - api/app/main.py
  - docker-compose.yml
autonomous: true

must_haves:
  truths:
    - "search_traces MCP tool calls POST /api/v1/traces/search and returns formatted results"
    - "contribute_trace MCP tool calls POST /api/v1/traces and returns trace ID"
    - "vote_trace MCP tool calls POST /api/v1/traces/{id}/votes and returns confirmation"
    - "get_trace MCP tool calls GET /api/v1/traces/{id} and returns formatted trace"
    - "list_tags MCP tool calls GET /api/v1/tags and returns tag list"
    - "GET /api/v1/tags returns distinct tag names from the database"
    - "MCP server starts via python -m app.server without errors"
  artifacts:
    - path: "mcp-server/app/server.py"
      provides: "FastMCP instance with 5 tool definitions"
      contains: "@mcp.tool"
    - path: "mcp-server/app/backend_client.py"
      provides: "httpx.AsyncClient wrapper for backend calls"
      contains: "class BackendClient"
    - path: "mcp-server/app/config.py"
      provides: "MCPSettings with all env vars"
      contains: "class MCPSettings"
    - path: "mcp-server/app/formatters.py"
      provides: "Format functions for MCP tool output"
      contains: "def format_search_results"
    - path: "api/app/routers/tags.py"
      provides: "GET /api/v1/tags endpoint"
      contains: "router"
    - path: "mcp-server/Dockerfile"
      provides: "Docker image for MCP server"
      contains: "fastmcp"
    - path: "docker-compose.yml"
      provides: "mcp-server service definition"
      contains: "mcp-server"
  key_links:
    - from: "mcp-server/app/server.py"
      to: "mcp-server/app/backend_client.py"
      via: "import backend singleton"
      pattern: "from app\\.backend_client import backend"
    - from: "mcp-server/app/server.py"
      to: "mcp-server/app/formatters.py"
      via: "format functions called per tool"
      pattern: "from app\\.formatters import"
    - from: "mcp-server/app/backend_client.py"
      to: "http://api:8000 (backend)"
      via: "httpx.AsyncClient POST/GET"
      pattern: "httpx\\.AsyncClient"
    - from: "api/app/main.py"
      to: "api/app/routers/tags.py"
      via: "include_router"
      pattern: "tags\\.router"
---

<objective>
Create the FastMCP 3.0.0 server with all five tool definitions, a backend HTTP client, response formatters, and the missing GET /api/v1/tags endpoint.

Purpose: Establish the MCP server as a thin protocol adapter that translates MCP tool calls into HTTP requests to the FastAPI backend. This plan creates every file in the mcp-server/app/ directory, installs dependencies, adds Docker support, and fills the API gap (list_tags).

Output: A working MCP server that can start via `python -m app.server`, with 5 tools defined, backend client ready for HTTP calls, and the tags endpoint added to the API.
</objective>

<execution_context>
@/home/bitnami/.claude/get-shit-done/workflows/execute-plan.md
@/home/bitnami/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-mcp-server/05-RESEARCH.md

@api/app/main.py
@api/app/routers/search.py
@api/app/routers/traces.py
@api/app/routers/votes.py
@api/app/schemas/search.py
@api/app/schemas/trace.py
@api/app/schemas/vote.py
@api/app/config.py
@api/Dockerfile
@docker-compose.yml
@mcp-server/pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: GET /api/v1/tags endpoint + MCP server skeleton with dependencies</name>
  <files>
    api/app/routers/tags.py
    api/app/main.py
    mcp-server/pyproject.toml
    mcp-server/app/__init__.py
    mcp-server/app/config.py
    mcp-server/app/backend_client.py
    mcp-server/Dockerfile
  </files>
  <action>
**Part A: Add GET /api/v1/tags to the API**

Create `api/app/routers/tags.py`:
- `router = APIRouter(prefix="/api/v1", tags=["tags"])`
- `GET /tags` endpoint: `async def list_tags(user: CurrentUser, db: DbSession, _rate: ReadRateLimit) -> dict`
- Query: `SELECT DISTINCT name FROM tags ORDER BY name` (use `select(Tag.name).order_by(Tag.name)`)
- Return: `{"tags": ["fastapi", "python", "react", ...]}` (plain list of strings)
- Uses existing `CurrentUser` auth dependency (read operation, not RequireEmail)
- Uses existing `ReadRateLimit` dependency

Register in `api/app/main.py`:
- Add `from app.routers import ... tags` to the imports
- Add `app.include_router(tags.router)` after the search router line

**Part B: Install MCP server dependencies**

Update `mcp-server/pyproject.toml`:
```toml
[project]
name = "commontrace-mcp"
version = "0.1.0"
requires-python = ">=3.12"
dependencies = [
    "fastmcp>=3.0.0",
    "pydantic-settings>=2.0.0",
    "structlog>=24.0",
]
```

Then run: `cd /home/bitnami/commontrace/mcp-server && uv sync`

**Part C: Create mcp-server/app/__init__.py** (empty file)

**Part D: Create mcp-server/app/config.py**

MCPSettings class (Pydantic BaseSettings):
```python
from pydantic_settings import BaseSettings, SettingsConfigDict

class MCPSettings(BaseSettings):
    model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8")

    api_base_url: str = "http://localhost:8000"
    commontrace_api_key: str = ""  # fallback for stdio transport
    mcp_transport: str = "stdio"   # "stdio" or "http"
    mcp_host: str = "0.0.0.0"
    mcp_port: int = 8080

    # Circuit breaker (used by Plan 05-02)
    circuit_failure_threshold: int = 5
    circuit_recovery_timeout: float = 30.0

    # SLA timeouts in seconds
    read_timeout: float = 0.2   # 200ms for search/get/list_tags
    write_timeout: float = 2.0  # 2s for contribute/vote

settings = MCPSettings()
```

**Part E: Create mcp-server/app/backend_client.py**

BackendClient class wrapping httpx.AsyncClient:
- Constructor: `httpx.AsyncClient(base_url=settings.api_base_url, timeout=httpx.Timeout(5.0, connect=2.0), limits=httpx.Limits(max_connections=20, max_keepalive_connections=10))`
- `async def post(self, path: str, json: dict, api_key: str, timeout: float = 2.0) -> dict` -- calls self.client.post with X-API-Key header, raise_for_status(), returns resp.json()
- `async def get(self, path: str, api_key: str, timeout: float = 0.5) -> dict` -- calls self.client.get with X-API-Key header, raise_for_status(), returns resp.json()
- `async def close(self)` -- calls self.client.aclose()
- Module-level singleton: `backend = BackendClient()`
- NOTE: No circuit breaker yet -- Plan 05-02 adds it. Keep methods simple for now (direct httpx calls, no try/except wrapping).
- Import timeout from asyncio for future use but do NOT wrap calls in asyncio.wait_for yet -- that is 05-02's concern.

**Part F: Create mcp-server/Dockerfile**

Follow the same pattern as api/Dockerfile:
```dockerfile
FROM python:3.12-slim AS base
RUN pip install uv
WORKDIR /app
COPY pyproject.toml .
RUN uv sync --frozen --no-dev || uv sync --no-dev
COPY . .
CMD ["python", "-m", "app.server"]
```
  </action>
  <verify>
    Run: `cd /home/bitnami/commontrace/mcp-server && uv sync` succeeds.
    Run: `cd /home/bitnami/commontrace/mcp-server && uv run python -c "from app.config import settings; print(settings.api_base_url)"` prints http://localhost:8000.
    Run: `cd /home/bitnami/commontrace/mcp-server && uv run python -c "from app.backend_client import backend; print(type(backend))"` prints BackendClient class.
    Run: `cd /home/bitnami/commontrace && uv run --project api python -c "from app.routers.tags import router; print(router.routes[0].path)"` prints /api/v1/tags.
  </verify>
  <done>
    mcp-server dependencies installed and importable. MCPSettings loads from env. BackendClient has post/get methods with httpx.AsyncClient. GET /api/v1/tags endpoint registered in FastAPI app. Dockerfile exists for mcp-server.
  </done>
</task>

<task type="auto">
  <name>Task 2: Five MCP tool definitions, response formatters, transport entrypoint, and Docker Compose service</name>
  <files>
    mcp-server/app/formatters.py
    mcp-server/app/server.py
    mcp-server/app/__main__.py
    docker-compose.yml
  </files>
  <action>
**Part A: Create mcp-server/app/formatters.py**

Functions that convert raw API JSON responses into clean, agent-readable strings. MCP tools return strings (not dicts) so agents can read them directly.

`format_search_results(data: dict) -> str`:
- Input: `{"results": [...], "total": N, "query": "..."}` from POST /traces/search
- Output: Multi-line string, e.g.:
  ```
  Found 3 results for "FastAPI JWT auth":

  1. [title] (score: 0.85, trust: 4.2)
     Tags: python, fastapi, jwt
     Context: [first 200 chars of context_text]...
     Solution: [first 200 chars of solution_text]...
     ID: uuid-here

  2. ...
  ```
- If results is empty: `"No traces found matching your query."`

`format_trace(data: dict) -> str`:
- Input: single trace JSON from GET /traces/{id}
- Output:
  ```
  [title]
  Status: validated | Trust: 4.2 | Tags: python, fastapi

  Context:
  [full context_text]

  Solution:
  [full solution_text]
  ```

`format_contribution_result(data: dict) -> str`:
- Input: `{"id": "uuid", "status": "pending"}` from POST /traces
- Output: `"Trace submitted successfully (ID: uuid). Status: pending â€” it will be validated after community review."`

`format_vote_result(data: dict) -> str`:
- Input: vote response JSON from POST /traces/{id}/votes
- Output: `"Vote recorded: [up/down]vote on trace [trace_id]."`

`format_tags(data: dict) -> str`:
- Input: `{"tags": ["fastapi", "python", ...]}` from GET /tags
- Output: `"Available tags (N total):\nfastapi, javascript, python, react, ..."` (comma-separated, sorted)

`format_error(status_code: int, detail: str) -> str`:
- Input: HTTP error status code and detail
- Output: `"[CommonTrace error] [detail] (HTTP [status_code])"` -- so agent sees a readable error without the session crashing

**Part B: Create mcp-server/app/server.py**

The main FastMCP server with all 5 tools. This IS the MCP server.

```python
from fastmcp import FastMCP
from fastmcp.server.dependencies import CurrentHeaders, Depends
```

Create `mcp` instance:
```python
mcp = FastMCP(
    name="CommonTrace",
    instructions=(
        "CommonTrace is a shared knowledge base for AI coding agents. "
        "Use search_traces to find solutions before writing code. "
        "Use contribute_trace after solving a problem to help future agents. "
        "Use vote_trace to rate traces you've used. "
        "Use get_trace to read a full trace by ID. "
        "Use list_tags to discover available filter tags."
    ),
)
```

Helper function for API key extraction (used by all tools):
```python
from app.config import settings

def _extract_api_key(headers: dict) -> str:
    """Extract API key from MCP client headers, fall back to env var for stdio."""
    api_key = headers.get("x-api-key", "")
    if not api_key:
        api_key = settings.commontrace_api_key
    return api_key
```

**Tool 1: search_traces** (read, 200ms SLA)
```python
@mcp.tool(annotations={"readOnlyHint": True, "openWorldHint": True})
async def search_traces(
    query: str = "",
    tags: list[str] = [],
    limit: int = 10,
    headers: dict = Depends(CurrentHeaders()),
) -> str:
    """Search CommonTrace for coding traces matching a natural language query and/or tags.

    Args:
        query: Natural language description of what you're looking for
        tags: Filter by tags like language, framework, or task type (AND semantics)
        limit: Maximum number of results (1-50, default 10)
    """
```
- Extract API key via `_extract_api_key(headers)`
- Validate: if not query and not tags, return `"Please provide a query, tags, or both to search."`
- Call: `backend.post("/api/v1/traces/search", json={"q": query or None, "tags": tags, "limit": limit}, api_key=api_key, timeout=settings.read_timeout)`
- Return: `format_search_results(result)`
- Catch httpx.HTTPStatusError: return `format_error(exc.response.status_code, exc.response.json().get("detail", "Search failed"))`
- Catch (httpx.HTTPError, Exception): return generic degradation message (Plan 05-02 refines this with circuit breaker, but basic try/except goes here)

**Tool 2: contribute_trace** (write, 2s SLA)
```python
@mcp.tool(annotations={"readOnlyHint": False})
async def contribute_trace(
    title: str,
    context_text: str,
    solution_text: str,
    tags: list[str] = [],
    headers: dict = Depends(CurrentHeaders()),
) -> str:
    """Submit a new trace to the CommonTrace knowledge base.

    Args:
        title: Short description of what this trace solves
        context_text: The problem context (what you were trying to do)
        solution_text: The solution (what worked)
        tags: Categorization tags (e.g., python, fastapi, docker)
    """
```
- Extract API key, call POST /api/v1/traces with json body, timeout=settings.write_timeout
- Return format_contribution_result(result)
- Same error handling pattern as search_traces

**Tool 3: vote_trace** (write, 2s SLA)
```python
@mcp.tool(annotations={"readOnlyHint": False})
async def vote_trace(
    trace_id: str,
    vote_type: str,
    feedback_tag: str = "",
    feedback_text: str = "",
    headers: dict = Depends(CurrentHeaders()),
) -> str:
    """Vote on a trace in the CommonTrace knowledge base.

    Args:
        trace_id: UUID of the trace to vote on
        vote_type: "up" or "down"
        feedback_tag: Required for downvotes. One of: outdated, wrong, security_concern, spam
        feedback_text: Optional explanation for your vote
    """
```
- Extract API key, build JSON body (include feedback_tag/feedback_text only if non-empty)
- Call POST /api/v1/traces/{trace_id}/votes, timeout=settings.write_timeout
- Return format_vote_result(result)

**Tool 4: get_trace** (read, 200ms SLA)
```python
@mcp.tool(annotations={"readOnlyHint": True})
async def get_trace(
    trace_id: str,
    headers: dict = Depends(CurrentHeaders()),
) -> str:
    """Get a specific trace by ID from the CommonTrace knowledge base.

    Args:
        trace_id: UUID of the trace to retrieve
    """
```
- Extract API key, call GET /api/v1/traces/{trace_id}, timeout=settings.read_timeout
- Return format_trace(result)

**Tool 5: list_tags** (read, 200ms SLA)
```python
@mcp.tool(annotations={"readOnlyHint": True})
async def list_tags(
    headers: dict = Depends(CurrentHeaders()),
) -> str:
    """List all available tags in the CommonTrace knowledge base."""
```
- Extract API key, call GET /api/v1/tags, timeout=settings.read_timeout
- Return format_tags(result)

**Health endpoint** (HTTP transport only):
```python
from starlette.responses import JSONResponse

@mcp.custom_route("/health", methods=["GET"])
async def health_check(request):
    return JSONResponse({"status": "healthy", "service": "commontrace-mcp"})
```

**Part C: Create mcp-server/app/__main__.py**

Entrypoint for `python -m app.server`:
```python
from app.server import mcp
from app.config import settings

if settings.mcp_transport == "http":
    mcp.run(transport="http", host=settings.mcp_host, port=settings.mcp_port)
else:
    mcp.run()  # stdio default
```

IMPORTANT: The `__main__.py` goes in `mcp-server/app/` so `python -m app.server` is NOT the entrypoint -- `python -m app` IS. Actually, to match the research recommendation of `python -m app.server`, create `mcp-server/app/server.py` as the module with tools AND put the `if __name__ == "__main__":` block at the bottom of server.py so both `python -m app.server` (direct module execution) and import work. The `__main__.py` at `mcp-server/app/__main__.py` enables `python -m app` as an alternative entry.

For `python -m app.server` to work, add at the bottom of server.py:
```python
if __name__ == "__main__":
    if settings.mcp_transport == "http":
        mcp.run(transport="http", host=settings.mcp_host, port=settings.mcp_port)
    else:
        mcp.run()
```

For `python -m app` to also work, `__main__.py`:
```python
from app.server import mcp
from app.config import settings

if settings.mcp_transport == "http":
    mcp.run(transport="http", host=settings.mcp_host, port=settings.mcp_port)
else:
    mcp.run()
```

**Part D: Update docker-compose.yml**

Add mcp-server service after the worker service:
```yaml
mcp-server:
  build:
    context: ./mcp-server
  env_file:
    - .env
  environment:
    - API_BASE_URL=http://api:8000
    - MCP_TRANSPORT=http
    - MCP_PORT=8080
  ports:
    - "8080:8080"
  depends_on:
    api:
      condition: service_started
```

Note: `service_started` not `service_healthy` -- the API doesn't need to be healthy for the MCP server to start (circuit breaker handles backend unavailability). But it DOES need to be started so Docker networking resolves the `api` hostname.
  </action>
  <verify>
    Run: `cd /home/bitnami/commontrace/mcp-server && uv run python -c "from app.server import mcp; print(mcp.name); print([t.name for t in mcp._tool_manager.tools.values()])"` -- prints "CommonTrace" and list of 5 tool names.
    Run: `cd /home/bitnami/commontrace/mcp-server && uv run python -c "from app.formatters import format_search_results; print(format_search_results({'results': [], 'total': 0, 'query': 'test'}))"` -- prints "No traces found" message.
    Run: `grep 'mcp-server' /home/bitnami/commontrace/docker-compose.yml` -- shows the mcp-server service definition.
    Run: `cd /home/bitnami/commontrace && uv run --project api python -c "from app.main import app; routes = [r.path for r in app.routes]; assert '/api/v1/tags' in routes; print('tags endpoint registered')"` -- prints confirmation.
  </verify>
  <done>
    Five MCP tools (search_traces, contribute_trace, vote_trace, get_trace, list_tags) defined in server.py with correct parameter types, docstrings, and annotations. All tools extract API key from headers with env var fallback. Formatters produce clean, agent-readable text output. Docker Compose includes mcp-server service on port 8080. Both `python -m app.server` and `python -m app` work as entrypoints.
  </done>
</task>

</tasks>

<verification>
1. `cd /home/bitnami/commontrace/mcp-server && uv run python -c "from app.server import mcp; print(len(mcp._tool_manager.tools))"` == 5
2. `cd /home/bitnami/commontrace/mcp-server && uv run python -c "from app.config import settings; assert settings.read_timeout == 0.2; assert settings.write_timeout == 2.0; print('SLAs configured')"` passes
3. `cd /home/bitnami/commontrace/mcp-server && uv run python -c "from app.backend_client import backend; print(backend.client.base_url)"` prints the configured base URL
4. `grep -c '@mcp.tool' /home/bitnami/commontrace/mcp-server/app/server.py` == 5
5. `cd /home/bitnami/commontrace && uv run --project api python -c "from app.main import app; print([r.path for r in app.routes if 'tags' in r.path])"` includes /api/v1/tags
</verification>

<success_criteria>
- MCP server has 5 tools that map to the 5 backend API endpoints
- Backend client can make POST and GET requests with API key forwarding
- GET /api/v1/tags endpoint exists in the FastAPI app
- Docker Compose can build and start the mcp-server service
- All formatters produce clean text output from API JSON responses
</success_criteria>

<output>
After completion, create `.planning/phases/05-mcp-server/05-01-SUMMARY.md`
</output>
