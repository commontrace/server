---
phase: 05-mcp-server
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - mcp-server/app/backend_client.py
  - mcp-server/app/server.py
autonomous: true

must_haves:
  truths:
    - "When backend is down, every MCP tool returns a human-readable degradation string -- never a ToolError, never an unhandled exception"
    - "When backend recovers after outage, circuit breaker transitions to half-open and allows a probe request through"
    - "Read operations (search, get_trace, list_tags) time out at 200ms; write operations (contribute, vote) time out at 2s"
    - "API key flows from MCP client headers (HTTP transport) or COMMONTRACE_API_KEY env var (stdio transport) -- never appears as a tool parameter"
    - "Circuit breaker opens after 5 consecutive failures and recovers after 30s"
  artifacts:
    - path: "mcp-server/app/backend_client.py"
      provides: "CircuitBreaker class + BackendClient with circuit-protected post/get"
      contains: "class CircuitBreaker"
    - path: "mcp-server/app/server.py"
      provides: "All 5 tools with try/except returning graceful degradation messages"
      contains: "CircuitOpenError"
  key_links:
    - from: "mcp-server/app/backend_client.py CircuitBreaker"
      to: "mcp-server/app/backend_client.py BackendClient.post/get"
      via: "self.breaker.call() wraps every HTTP request"
      pattern: "self\\.breaker\\.call"
    - from: "mcp-server/app/server.py (each tool)"
      to: "mcp-server/app/backend_client.py (CircuitOpenError, BackendUnavailableError)"
      via: "try/except returning string messages"
      pattern: "except (CircuitOpenError|BackendUnavailableError)"
    - from: "mcp-server/app/server.py _extract_api_key"
      to: "CurrentHeaders() (HTTP) or settings.commontrace_api_key (stdio)"
      via: "headers.get fallback to env var"
      pattern: "headers\\.get.*x-api-key.*settings\\.commontrace_api_key"
---

<objective>
Add circuit-breaker protection, per-operation SLA timeouts, and graceful degradation to every MCP tool. Ensure API key injection works for both HTTP and stdio transports.

Purpose: Fulfill MCP-03 (circuit breaking) and MCP-04 (dual transport) requirements. When the CommonTrace backend is unavailable, slow, or erroring, the MCP server must return helpful text messages that allow the agent session to continue. API keys must flow invisibly from MCP client configuration.

Output: A resilient MCP server where no backend failure can crash an agent session, with measurable SLA timeouts per operation type.
</objective>

<execution_context>
@/home/bitnami/.claude/get-shit-done/workflows/execute-plan.md
@/home/bitnami/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-mcp-server/05-RESEARCH.md
@.planning/phases/05-mcp-server/05-01-SUMMARY.md

@mcp-server/app/backend_client.py
@mcp-server/app/server.py
@mcp-server/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: CircuitBreaker class and circuit-protected BackendClient</name>
  <files>mcp-server/app/backend_client.py</files>
  <action>
**Read the existing backend_client.py from Plan 05-01 first.** Then modify it to add the circuit breaker.

**Part A: Add custom exception classes** at the top of the file (before BackendClient):

```python
class CircuitOpenError(Exception):
    """Raised when circuit breaker is open and requests are blocked."""
    pass

class BackendUnavailableError(Exception):
    """Raised when a backend call fails (timeout, connection error, HTTP error)."""
    pass
```

**Part B: Add CircuitBreaker class** (~50 lines, custom, no third-party library):

```python
import asyncio
import time

class CircuitBreaker:
    """Async circuit breaker with three states: closed, open, half-open.

    - closed: requests flow normally, failures are counted
    - open: requests are immediately rejected with CircuitOpenError
    - half-open: one probe request is allowed; success -> closed, failure -> open
    """

    def __init__(self, failure_threshold: int = 5, recovery_timeout: float = 30.0):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.failure_count = 0
        self.last_failure_time = 0.0
        self.state = "closed"

    async def call(self, coro, timeout: float):
        """Execute coroutine with circuit breaker protection and timeout."""
        if self.state == "open":
            if time.monotonic() - self.last_failure_time > self.recovery_timeout:
                self.state = "half-open"
            else:
                raise CircuitOpenError(
                    "CommonTrace backend is temporarily unavailable. "
                    "Please try again in a few seconds."
                )

        try:
            result = await asyncio.wait_for(coro, timeout=timeout)
            self._on_success()
            return result
        except (httpx.HTTPError, asyncio.TimeoutError, ConnectionError, OSError) as exc:
            self._on_failure()
            raise BackendUnavailableError(str(exc)) from exc

    def _on_success(self):
        self.failure_count = 0
        self.state = "closed"

    def _on_failure(self):
        self.failure_count += 1
        self.last_failure_time = time.monotonic()
        if self.failure_count >= self.failure_threshold:
            self.state = "open"
```

Key details:
- `call()` accepts a coroutine (not awaited yet) and a timeout in seconds
- `asyncio.wait_for` handles the per-operation SLA timeout
- Catches `httpx.HTTPError` (base class for all httpx errors including status errors from raise_for_status()), `asyncio.TimeoutError`, `ConnectionError`, and `OSError` (covers socket-level failures)
- On success in half-open state, resets to closed (via `_on_success`)
- On failure in half-open state, re-opens (via `_on_failure` which increments past threshold)
- `time.monotonic()` for timing (not `time.time()`) -- monotonic is immune to clock adjustments

**Part C: Update BackendClient to use CircuitBreaker**

Modify the existing BackendClient:

```python
class BackendClient:
    def __init__(self):
        self.client = httpx.AsyncClient(
            base_url=settings.api_base_url,
            timeout=httpx.Timeout(5.0, connect=2.0),
            limits=httpx.Limits(max_connections=20, max_keepalive_connections=10),
        )
        self.breaker = CircuitBreaker(
            failure_threshold=settings.circuit_failure_threshold,
            recovery_timeout=settings.circuit_recovery_timeout,
        )

    async def post(self, path: str, json: dict, api_key: str, timeout: float = 2.0) -> dict:
        """POST to backend with circuit breaker protection."""
        async def _request():
            resp = await self.client.post(
                path,
                json=json,
                headers={"X-API-Key": api_key},
            )
            resp.raise_for_status()
            return resp.json()
        return await self.breaker.call(_request(), timeout=timeout)

    async def get(self, path: str, api_key: str, timeout: float = 0.5) -> dict:
        """GET from backend with circuit breaker protection."""
        async def _request():
            resp = await self.client.get(
                path,
                headers={"X-API-Key": api_key},
            )
            resp.raise_for_status()
            return resp.json()
        return await self.breaker.call(_request(), timeout=timeout)

    async def close(self):
        await self.client.aclose()
```

CRITICAL: The inner `_request()` function is `async def` and returns a coroutine when called. `self.breaker.call(_request(), timeout=...)` passes the coroutine object (not awaited) to `asyncio.wait_for` inside the circuit breaker. This is correct -- do NOT await `_request()` before passing to `call()`.

Keep the module-level singleton: `backend = BackendClient()`

**Part D: Export exceptions for use in server.py**

Ensure `CircuitOpenError` and `BackendUnavailableError` are importable:
```python
# These are already at module level from Part A
# server.py will: from app.backend_client import backend, CircuitOpenError, BackendUnavailableError
```
  </action>
  <verify>
    Run: `cd /home/bitnami/commontrace/mcp-server && uv run python -c "
from app.backend_client import CircuitBreaker, CircuitOpenError, BackendUnavailableError
cb = CircuitBreaker(failure_threshold=2, recovery_timeout=1.0)
print(f'State: {cb.state}, Failures: {cb.failure_count}')
print('CircuitBreaker imports OK, state is closed')
"`
    Run: `cd /home/bitnami/commontrace/mcp-server && uv run python -c "
from app.backend_client import backend
print(f'Breaker state: {backend.breaker.state}')
print(f'Failure threshold: {backend.breaker.failure_threshold}')
print(f'Recovery timeout: {backend.breaker.recovery_timeout}')
print('BackendClient has circuit breaker')
"`
  </verify>
  <done>
    CircuitBreaker class exists with closed/open/half-open states. BackendClient.post() and BackendClient.get() are wrapped with self.breaker.call(). CircuitOpenError raised when circuit is open. BackendUnavailableError raised on timeout or connection failure. Failure threshold = 5, recovery timeout = 30s (configurable via settings).
  </done>
</task>

<task type="auto">
  <name>Task 2: Graceful degradation in all MCP tools and API key injection verification</name>
  <files>mcp-server/app/server.py</files>
  <action>
**Read the existing server.py from Plan 05-01 first.** Then wrap every tool's backend call in try/except blocks that return degradation messages as strings.

**Part A: Import circuit breaker exceptions**

Add to server.py imports:
```python
from app.backend_client import backend, CircuitOpenError, BackendUnavailableError
from app.formatters import (
    format_search_results, format_trace, format_contribution_result,
    format_vote_result, format_tags, format_error,
)
```

**Part B: Update EVERY tool with the graceful degradation pattern**

Each tool must follow this pattern. The key rule: **return a string, never raise ToolError or let exceptions propagate**.

For **read tools** (search_traces, get_trace, list_tags):
```python
try:
    result = await backend.post(...)  # or backend.get(...)
    return format_...(result)
except CircuitOpenError:
    return (
        "[CommonTrace unavailable] The knowledge base is temporarily unreachable. "
        "Continuing without trace lookup. You can retry later."
    )
except BackendUnavailableError:
    return (
        "[CommonTrace timeout] Request took too long and was cancelled. "
        "The knowledge base may be under heavy load. Continuing without results."
    )
except Exception as exc:
    return f"[CommonTrace error] Unexpected error: {exc}. Continuing without results."
```

For **write tools** (contribute_trace, vote_trace):
```python
try:
    result = await backend.post(...)
    return format_...(result)
except CircuitOpenError:
    return (
        "[CommonTrace unavailable] The knowledge base is temporarily unreachable. "
        "Your contribution could not be submitted. Please try again later."
    )
except BackendUnavailableError:
    return (
        "[CommonTrace timeout] The submission took too long and was cancelled. "
        "The knowledge base may be under heavy load. Please try again later."
    )
except Exception as exc:
    return f"[CommonTrace error] Unexpected error: {exc}. Your submission was not recorded."
```

CRITICAL DIFFERENCES between read and write degradation messages:
- Read tools say "Continuing without results" (agent moves on, no data loss)
- Write tools say "Please try again later" (agent knows submission was NOT saved)

**Part C: Handle HTTP status errors separately from circuit breaker errors**

Inside each tool's try/except, add an `httpx.HTTPStatusError` catch BEFORE the generic exception. This handles cases where the backend returns 4xx/5xx but the circuit breaker is still closed (e.g., 401 auth error, 422 validation error):

```python
import httpx

try:
    result = await backend.post(...)
    return format_...(result)
except CircuitOpenError:
    return "[CommonTrace unavailable] ..."
except BackendUnavailableError:
    return "[CommonTrace timeout] ..."
except httpx.HTTPStatusError as exc:
    detail = "Unknown error"
    try:
        detail = exc.response.json().get("detail", str(exc))
    except Exception:
        detail = str(exc)
    return format_error(exc.response.status_code, detail)
except Exception as exc:
    return f"[CommonTrace error] Unexpected error: {exc}. ..."
```

Wait -- `httpx.HTTPStatusError` is a subclass of `httpx.HTTPError` which is caught inside the CircuitBreaker, converting it to `BackendUnavailableError`. This means 4xx/5xx errors will be caught by the circuit breaker and count as failures. This is WRONG for 4xx errors (client errors like 401, 422 should not trip the circuit).

**REVISED approach:** In BackendClient, do NOT call `resp.raise_for_status()` inside the circuit breaker. Instead:

Update `backend_client.py` post() and get() methods:
```python
async def post(self, path: str, json: dict, api_key: str, timeout: float = 2.0) -> dict:
    async def _request():
        resp = await self.client.post(
            path, json=json, headers={"X-API-Key": api_key},
        )
        return resp  # Return raw response, NOT raise_for_status()
    resp = await self.breaker.call(_request(), timeout=timeout)
    # 4xx errors are client errors, not backend failures -- don't trip circuit
    if resp.status_code >= 500:
        # Server error -- manually trip circuit breaker tracking
        self.breaker._on_failure()
        raise BackendUnavailableError(f"Backend returned {resp.status_code}")
    resp.raise_for_status()  # Raises httpx.HTTPStatusError for 4xx
    return resp.json()
```

Same pattern for `get()`.

This way:
- Connection errors, timeouts -> caught by circuit breaker -> BackendUnavailableError
- 5xx errors -> circuit breaker failure tracking + BackendUnavailableError
- 4xx errors -> httpx.HTTPStatusError raised OUTSIDE circuit breaker (does NOT count as failure)
- 2xx -> success, circuit breaker resets

Then in server.py tools:
```python
try:
    result = await backend.post(...)
    return format_...(result)
except CircuitOpenError:
    return "[CommonTrace unavailable] ..."
except BackendUnavailableError:
    return "[CommonTrace timeout] ..."
except httpx.HTTPStatusError as exc:
    detail = "Unknown error"
    try:
        detail = exc.response.json().get("detail", str(exc))
    except Exception:
        detail = str(exc)
    return format_error(exc.response.status_code, detail)
except Exception as exc:
    return f"[CommonTrace error] ..."
```

**Part D: Verify API key injection works for both transports**

The `_extract_api_key(headers)` function from Plan 05-01 already handles:
- HTTP transport: `headers.get("x-api-key", "")` extracts from MCP client headers
- stdio transport: fallback to `settings.commontrace_api_key` when headers is empty dict

Verify this function exists and is called in every tool. If Plan 05-01 already implemented it, just confirm it's correct. The critical detail: `CurrentHeaders()` returns `{}` (empty dict) for stdio transport, and `Depends()` wrapper hides the `headers` parameter from the tool's MCP schema.

Add `import httpx` to server.py if not already present (needed for `httpx.HTTPStatusError` catch).

**Part E: Verify no ToolError imports or usage**

Search server.py for any import or usage of `ToolError` from `fastmcp.exceptions`. If found, REMOVE it. We explicitly do NOT use ToolError -- all errors are returned as strings.
  </action>
  <verify>
    Run: `cd /home/bitnami/commontrace/mcp-server && uv run python -c "
from app.backend_client import backend, CircuitOpenError, BackendUnavailableError
# Verify circuit breaker is wired
assert hasattr(backend, 'breaker')
assert backend.breaker.state == 'closed'
print('Circuit breaker wired to BackendClient')
"`
    Run: `cd /home/bitnami/commontrace/mcp-server && uv run python -c "
import inspect
from app.server import search_traces, contribute_trace, vote_trace, get_trace, list_tags
# Verify all tools have the try/except pattern
for tool_fn in [search_traces, contribute_trace, vote_trace, get_trace, list_tags]:
    src = inspect.getsource(tool_fn)
    assert 'CircuitOpenError' in src, f'{tool_fn.__name__} missing CircuitOpenError handling'
    assert 'BackendUnavailableError' in src, f'{tool_fn.__name__} missing BackendUnavailableError handling'
    assert 'ToolError' not in src, f'{tool_fn.__name__} must NOT use ToolError'
print('All 5 tools have graceful degradation, no ToolError')
"`
    Run: `cd /home/bitnami/commontrace/mcp-server && uv run python -c "
from app.server import _extract_api_key
# HTTP transport: header present
assert _extract_api_key({'x-api-key': 'ct_test123'}) == 'ct_test123'
# stdio transport: empty headers, falls back to env var
import os
os.environ['COMMONTRACE_API_KEY'] = 'ct_from_env'
from app.config import MCPSettings
settings = MCPSettings()
assert _extract_api_key({}) == settings.commontrace_api_key or _extract_api_key({}) == 'ct_from_env'
print('API key injection works for both transports')
"`
    Run: `grep -c 'ToolError' /home/bitnami/commontrace/mcp-server/app/server.py` returns 0.
  </verify>
  <done>
    Every MCP tool catches CircuitOpenError, BackendUnavailableError, httpx.HTTPStatusError, and generic Exception -- returning human-readable degradation strings in all cases. No ToolError is used anywhere. Circuit breaker opens after 5 failures, blocks for 30s, then allows a probe in half-open state. 4xx errors do NOT trip the circuit breaker (only 5xx, timeouts, and connection errors do). API key extracted from headers (HTTP) or env var (stdio) in every tool.
  </done>
</task>

</tasks>

<verification>
1. `grep -c 'ToolError' /home/bitnami/commontrace/mcp-server/app/server.py` == 0
2. `grep -c 'CircuitOpenError' /home/bitnami/commontrace/mcp-server/app/server.py` >= 5 (one per tool)
3. `grep -c 'BackendUnavailableError' /home/bitnami/commontrace/mcp-server/app/server.py` >= 5 (one per tool)
4. `grep 'class CircuitBreaker' /home/bitnami/commontrace/mcp-server/app/backend_client.py` exists
5. `grep 'self.breaker.call' /home/bitnami/commontrace/mcp-server/app/backend_client.py` appears in both post() and get()
6. `grep '_extract_api_key' /home/bitnami/commontrace/mcp-server/app/server.py` appears in all 5 tools
7. `grep 'settings.read_timeout' /home/bitnami/commontrace/mcp-server/app/server.py` appears for read tools (search, get_trace, list_tags)
8. `grep 'settings.write_timeout' /home/bitnami/commontrace/mcp-server/app/server.py` appears for write tools (contribute, vote)
</verification>

<success_criteria>
- Circuit breaker protects every backend call with configurable failure threshold and recovery timeout
- Read operations use 200ms timeout; write operations use 2s timeout
- Backend failures return graceful degradation strings (never ToolError, never unhandled exceptions)
- 4xx HTTP errors return formatted error messages without tripping the circuit breaker
- 5xx errors, timeouts, and connection failures count toward circuit breaker failure threshold
- API key injection works for HTTP transport (headers) and stdio transport (env var fallback)
- No ToolError import or usage exists in server.py
</success_criteria>

<output>
After completion, create `.planning/phases/05-mcp-server/05-02-SUMMARY.md`
</output>
