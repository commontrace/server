---
phase: 04-reputation-engine
plan: "02"
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - api/app/services/trust.py
  - api/app/routers/votes.py
  - api/app/routers/traces.py
  - api/app/routers/amendments.py
  - api/app/routers/reputation.py
  - api/app/main.py
autonomous: true

must_haves:
  truths:
    - "A vote on a tagged trace updates the trace contributor's per-domain reputation for each tag"
    - "Vote weight is derived from the voter's domain reputation for the trace's tags — a voter with established Python reputation has higher weight on Python traces than a new contributor"
    - "A new contributor's vote weight is BASE_WEIGHT=0.1, creating a measurable 8:1 difference vs an established contributor with wilson_score=0.8"
    - "POST /traces, POST /votes, POST /amendments all require email registration (403 without email)"
    - "GET /api/v1/contributors/{user_id}/reputation returns overall Wilson score and per-domain breakdown"
    - "Overall users.reputation_score is recomputed as aggregate Wilson score across all domains after each vote"
  artifacts:
    - path: "api/app/services/trust.py"
      provides: "update_contributor_domain_reputation and get_vote_weight_for_trace functions"
      contains: "update_contributor_domain_reputation"
    - path: "api/app/routers/votes.py"
      provides: "Vote endpoint wired with RequireEmail, domain vote weight, and reputation update"
      contains: "RequireEmail"
    - path: "api/app/routers/reputation.py"
      provides: "GET /api/v1/contributors/{user_id}/reputation endpoint"
      contains: "get_contributor_reputation"
    - path: "api/app/routers/traces.py"
      provides: "Trace submission gated by RequireEmail"
      contains: "RequireEmail"
    - path: "api/app/routers/amendments.py"
      provides: "Amendment submission gated by RequireEmail"
      contains: "RequireEmail"
    - path: "api/app/main.py"
      provides: "Reputation router registered"
      contains: "reputation"
  key_links:
    - from: "api/app/routers/votes.py"
      to: "api/app/services/trust.py"
      via: "get_vote_weight_for_trace called before apply_vote_to_trace"
      pattern: "get_vote_weight_for_trace"
    - from: "api/app/routers/votes.py"
      to: "api/app/services/trust.py"
      via: "update_contributor_domain_reputation called after apply_vote_to_trace"
      pattern: "update_contributor_domain_reputation"
    - from: "api/app/services/trust.py"
      to: "api/app/models/reputation.py"
      via: "UPSERT into ContributorDomainReputation via pg_insert ON CONFLICT"
      pattern: "pg_insert.*ContributorDomainReputation"
    - from: "api/app/routers/reputation.py"
      to: "api/app/models/reputation.py"
      via: "SELECT from ContributorDomainReputation for domain breakdown"
      pattern: "select.*ContributorDomainReputation"
---

<objective>
Wire the reputation engine into the live vote flow: domain-aware vote weight lookup, per-domain reputation update on each vote, RequireEmail gate on all write endpoints, and a read-only reputation endpoint.

Purpose: This plan makes the reputation engine operational. After this plan, CONT-03 (vote weight by reputation), REPU-01 (Wilson score trust), REPU-02 (email identity cost), and REPU-03 (per-domain reputation) are all fulfilled.

Output: Votes use domain-weighted vote_weight, per-domain reputation rows are created/updated atomically, write endpoints require email, reputation is readable via GET endpoint.
</objective>

<execution_context>
@/home/bitnami/.claude/get-shit-done/workflows/execute-plan.md
@/home/bitnami/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-reputation-engine/04-RESEARCH.md
@.planning/phases/04-reputation-engine/04-01-SUMMARY.md
@api/app/services/trust.py
@api/app/routers/votes.py
@api/app/routers/traces.py
@api/app/routers/amendments.py
@api/app/main.py
@api/app/dependencies.py
@api/app/models/reputation.py
@api/app/schemas/reputation.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Domain reputation update + vote weight functions in trust service</name>
  <files>
    api/app/services/trust.py
  </files>
  <action>
Add two new async functions to `api/app/services/trust.py`. These extend the existing trust service with domain-aware reputation logic.

**Add required imports at the top of trust.py:**
```python
from sqlalchemy import func
from sqlalchemy.dialects.postgresql import insert as pg_insert
from app.models.reputation import ContributorDomainReputation, CDR_UNIQUE_CONSTRAINT
from app.models.user import User
```

**1. Add `get_vote_weight_for_trace` function:**

```python
# Minimum weight for new contributors — creates measurable difference vs established
# contributors per REPU-01 success criterion. An established contributor with
# wilson_score=0.8 has 8x the vote influence of a new contributor.
BASE_WEIGHT = 0.1


async def get_vote_weight_for_trace(
    db: AsyncSession,
    voter_id: uuid.UUID,
    trace_tags: list[str],
) -> float:
    """Get the voter's effective weight for a trace based on domain reputation.

    Finds all domain reputation rows for this voter matching any of the trace's
    tags. Returns the maximum Wilson score across matching domains, or BASE_WEIGHT
    if no domain match exists.

    When trace has no tags, falls back to users.reputation_score (the global
    Wilson score). This is correct — untagged traces are domain-agnostic.

    Args:
        db: Async SQLAlchemy session.
        voter_id: UUID of the user casting the vote.
        trace_tags: List of normalized tag name strings from the trace.

    Returns:
        Vote weight as a float >= BASE_WEIGHT.
    """
    if not trace_tags:
        result = await db.execute(
            select(User.reputation_score).where(User.id == voter_id)
        )
        overall = result.scalar_one_or_none() or BASE_WEIGHT
        return max(BASE_WEIGHT, overall)

    result = await db.execute(
        select(ContributorDomainReputation.wilson_score)
        .where(ContributorDomainReputation.contributor_id == voter_id)
        .where(ContributorDomainReputation.domain_tag.in_(trace_tags))
    )
    domain_scores = [row[0] for row in result.fetchall()]

    if not domain_scores:
        return BASE_WEIGHT
    return max(BASE_WEIGHT, max(domain_scores))
```

**2. Add `update_contributor_domain_reputation` function:**

```python
async def update_contributor_domain_reputation(
    db: AsyncSession,
    contributor_id: uuid.UUID,
    domain_tags: list[str],
    is_upvote: bool,
) -> None:
    """Atomically update per-domain reputation for a trace contributor.

    For each domain tag on the voted trace, upserts a
    contributor_domain_reputation row incrementing the appropriate counter,
    then recomputes and stores the Wilson score.

    Also updates users.reputation_score with the aggregate Wilson score
    across all domains.

    Args:
        db: Async SQLAlchemy session (caller manages commit).
        contributor_id: UUID of the trace author receiving the reputation effect.
        domain_tags: Normalized tag names from the voted trace.
        is_upvote: True for upvote, False for downvote.
    """
    if not domain_tags:
        return

    for tag in domain_tags:
        up_delta = 1 if is_upvote else 0
        down_delta = 0 if is_upvote else 1

        stmt = pg_insert(ContributorDomainReputation).values(
            contributor_id=contributor_id,
            domain_tag=tag,
            upvote_count=up_delta,
            downvote_count=down_delta,
            wilson_score=0.0,
        ).on_conflict_do_update(
            constraint=CDR_UNIQUE_CONSTRAINT,
            set_={
                "upvote_count": ContributorDomainReputation.upvote_count + up_delta,
                "downvote_count": ContributorDomainReputation.downvote_count + down_delta,
            }
        ).returning(
            ContributorDomainReputation.upvote_count,
            ContributorDomainReputation.downvote_count,
            ContributorDomainReputation.id,
        )

        result = await db.execute(stmt)
        row = result.one()
        new_wilson = wilson_score_lower_bound(
            row.upvote_count, row.upvote_count + row.downvote_count
        )

        await db.execute(
            update(ContributorDomainReputation)
            .where(ContributorDomainReputation.id == row.id)
            .values(wilson_score=new_wilson)
            .execution_options(synchronize_session=False)
        )

    # Recompute aggregate Wilson score on users.reputation_score
    agg_result = await db.execute(
        select(
            func.sum(ContributorDomainReputation.upvote_count),
            func.sum(ContributorDomainReputation.downvote_count),
        ).where(ContributorDomainReputation.contributor_id == contributor_id)
    )
    agg_row = agg_result.one()
    total_up = agg_row[0] or 0
    total_down = agg_row[1] or 0
    overall_wilson = wilson_score_lower_bound(total_up, total_up + total_down)

    await db.execute(
        update(User)
        .where(User.id == contributor_id)
        .values(reputation_score=overall_wilson)
        .execution_options(synchronize_session=False)
    )
```

Keep the existing `apply_vote_to_trace` function unchanged.
  </action>
  <verify>
Run `python -c "from app.services.trust import get_vote_weight_for_trace, update_contributor_domain_reputation, wilson_score_lower_bound, apply_vote_to_trace; print('All trust functions importable')"` from the api directory.
  </verify>
  <done>
trust.py exports four functions: wilson_score_lower_bound (from 04-01), apply_vote_to_trace (existing), get_vote_weight_for_trace (new), update_contributor_domain_reputation (new). BASE_WEIGHT=0.1 is defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire RequireEmail + domain vote weight into routers + reputation endpoint + router registration</name>
  <files>
    api/app/routers/votes.py
    api/app/routers/traces.py
    api/app/routers/amendments.py
    api/app/routers/reputation.py
    api/app/main.py
  </files>
  <action>
**1. Update `api/app/routers/votes.py` — the most critical wiring:**

Replace `CurrentUser` with `RequireEmail` on the `cast_vote` endpoint. Update imports:
- Add: `from app.dependencies import RequireEmail, DbSession` (replace `CurrentUser` import with `RequireEmail`)
- Add: `from app.services.trust import apply_vote_to_trace, get_vote_weight_for_trace, update_contributor_domain_reputation`
- Add: `from app.models.tag import Tag, trace_tags` (needed to fetch trace tags)
- Add: `from sqlalchemy.orm import selectinload`

Change the endpoint signature parameter from `user: CurrentUser` to `user: RequireEmail`.

After the trace lookup (line `trace = result.scalar_one_or_none()`) and before vote creation, add tag fetching:
```python
# Fetch trace tags for domain reputation lookup
tag_result = await db.execute(
    select(Tag.name)
    .join(trace_tags, Tag.id == trace_tags.c.tag_id)
    .where(trace_tags.c.trace_id == trace_id)
)
tag_names = [row[0] for row in tag_result.fetchall()]
```

Replace the existing `vote_weight` computation (line 87: `vote_weight=user.reputation_score if user.reputation_score > 0 else 1.0`) with the domain-aware call:
```python
vote_weight = await get_vote_weight_for_trace(
    db=db, voter_id=user.id, trace_tags=tag_names,
)
```

After `apply_vote_to_trace(...)` and before `await db.commit()`, add the domain reputation update:
```python
# Update trace contributor's per-domain reputation
await update_contributor_domain_reputation(
    db=db,
    contributor_id=trace.contributor_id,
    domain_tags=tag_names,
    is_upvote=(body.vote_type == "up"),
)
```

The full vote flow becomes:
1. RequireEmail (auth + email gate)
2. WriteRateLimit
3. Trace lookup + tag fetch
4. Self-vote check
5. Vote INSERT + flush
6. get_vote_weight_for_trace (domain-aware weight)
7. apply_vote_to_trace (existing — atomic trust score update)
8. update_contributor_domain_reputation (domain reputation upsert)
9. db.commit()

**2. Update `api/app/routers/traces.py` — add RequireEmail:**

Import `RequireEmail` from dependencies (add to existing import line). Change `submit_trace` parameter from `user: CurrentUser` to `user: RequireEmail`. Keep `get_trace` using `CurrentUser` (reads don't require email per research — anti-pattern to gate GETs).

**3. Update `api/app/routers/amendments.py` — add RequireEmail:**

Import `RequireEmail` from dependencies (add to existing import line). Change `submit_amendment` parameter from `user: CurrentUser` to `user: RequireEmail`.

**4. Create `api/app/routers/reputation.py` — read-only reputation endpoint:**

```python
"""Contributor reputation endpoint.

GET /api/v1/contributors/{user_id}/reputation -- overall + per-domain breakdown
"""

import uuid

from fastapi import APIRouter, HTTPException
from sqlalchemy import select

from app.dependencies import CurrentUser, DbSession
from app.middleware.rate_limiter import ReadRateLimit
from app.models.reputation import ContributorDomainReputation
from app.models.user import User
from app.schemas.reputation import DomainReputationItem, ReputationResponse

router = APIRouter(prefix="/api/v1", tags=["reputation"])


@router.get(
    "/contributors/{user_id}/reputation",
    response_model=ReputationResponse,
)
async def get_contributor_reputation(
    user_id: uuid.UUID,
    user: CurrentUser,
    db: DbSession,
    _rate: ReadRateLimit,
) -> ReputationResponse:
    """Get a contributor's overall reputation and per-domain breakdown.

    Returns the aggregate Wilson score (from users.reputation_score) and
    a list of per-domain reputation items ordered by Wilson score descending.

    Any authenticated user can query any contributor's reputation.
    """
    result = await db.execute(select(User).where(User.id == user_id))
    contributor = result.scalar_one_or_none()
    if contributor is None:
        raise HTTPException(status_code=404, detail="Contributor not found")

    domain_result = await db.execute(
        select(ContributorDomainReputation)
        .where(ContributorDomainReputation.contributor_id == user_id)
        .order_by(ContributorDomainReputation.wilson_score.desc())
    )
    domain_rows = domain_result.scalars().all()

    return ReputationResponse(
        user_id=contributor.id,
        overall_wilson_score=contributor.reputation_score,
        domains=[
            DomainReputationItem(
                domain_tag=row.domain_tag,
                wilson_score=row.wilson_score,
                upvote_count=row.upvote_count,
                downvote_count=row.downvote_count,
            )
            for row in domain_rows
        ],
    )
```

Uses `CurrentUser` not `RequireEmail` — reading reputation does not require email (consistent with read-only access pattern).

**5. Update `api/app/main.py` — register reputation router:**

Add import: `from app.routers import amendments, auth, moderation, reputation, search, traces, votes`

Add after the search router registration:
```python
# Reputation router (04-02)
app.include_router(reputation.router)
```
  </action>
  <verify>
1. Run `python -c "from app.routers.votes import cast_vote; print('votes router imports OK')"` from api dir
2. Run `python -c "from app.routers.reputation import get_contributor_reputation; print('reputation router imports OK')"` from api dir
3. Run `python -c "from app.main import app; routes = [r.path for r in app.routes]; assert '/api/v1/contributors/{user_id}/reputation' in routes, f'Missing reputation route. Routes: {routes}'; print('Reputation route registered')"` from api dir
4. Verify RequireEmail is used on write endpoints: `grep -n "RequireEmail" api/app/routers/votes.py api/app/routers/traces.py api/app/routers/amendments.py` shows matches in all three files
5. Verify CurrentUser still used on reads: `grep -n "CurrentUser" api/app/routers/traces.py api/app/routers/reputation.py` shows matches for get_trace and get_contributor_reputation
  </verify>
  <done>
Vote flow uses domain-aware vote_weight via get_vote_weight_for_trace (BASE_WEIGHT=0.1 for new contributors). Each vote triggers update_contributor_domain_reputation which atomically upserts per-domain rows and recomputes users.reputation_score. POST /traces, POST /votes, POST /amendments all gated by RequireEmail (403 without email). GET endpoints use CurrentUser (no email gate). GET /api/v1/contributors/{user_id}/reputation returns overall + per-domain breakdown. Reputation router registered in main.py.
  </done>
</task>

</tasks>

<verification>
- Import chain: `app.services.trust` imports from `app.models.reputation` (CDR_UNIQUE_CONSTRAINT, ContributorDomainReputation) and `app.models.user` (User)
- Vote router: imports `get_vote_weight_for_trace` and `update_contributor_domain_reputation` from trust service
- RequireEmail applied to: POST /traces, POST /traces/{id}/votes, POST /traces/{id}/amendments
- RequireEmail NOT applied to: POST /api/v1/keys, GET /traces/{id}, GET /contributors/{id}/reputation, GET /moderation/flagged
- Reputation endpoint returns overall_wilson_score from users.reputation_score and domains list from contributor_domain_reputation rows
- BASE_WEIGHT=0.1 creates measurable vote weight difference (REPU-01 criterion)
</verification>

<success_criteria>
- Votes use domain-weighted vote_weight from get_vote_weight_for_trace (not the old `reputation_score or 1.0` pattern)
- Per-domain reputation rows are created/updated atomically via ON CONFLICT DO UPDATE
- Overall users.reputation_score is recomputed as aggregate Wilson score after each vote
- All write endpoints return 403 for users without email registration
- GET /api/v1/contributors/{user_id}/reputation is live and returns structured response
- Requirements fulfilled: CONT-03, REPU-01, REPU-02, REPU-03
</success_criteria>

<output>
After completion, create `.planning/phases/04-reputation-engine/04-02-SUMMARY.md`
</output>
