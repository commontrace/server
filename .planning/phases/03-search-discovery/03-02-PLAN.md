---
phase: 03-search-discovery
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - api/app/schemas/search.py
  - api/app/routers/search.py
  - api/app/main.py
autonomous: true

must_haves:
  truths:
    - "An agent can POST a natural language query to /api/v1/traces/search and receive semantically ranked results"
    - "An agent can filter search results by one or more tags and receive only traces matching ALL specified tags"
    - "A single search request with both query text and tags returns results satisfying both semantic similarity and tag constraints"
    - "A trace with high trust_score ranks above an identical-distance trace with low trust_score"
    - "Traces with is_flagged=True or embedding IS NULL do not appear in search results"
  artifacts:
    - path: "api/app/schemas/search.py"
      provides: "TraceSearchRequest, TraceSearchResult, TraceSearchResponse Pydantic models"
      contains: "TraceSearchRequest"
    - path: "api/app/routers/search.py"
      provides: "POST /api/v1/traces/search endpoint with hybrid query"
      contains: "cosine_distance"
    - path: "api/app/main.py"
      provides: "Search router registered on FastAPI app"
      contains: "search"
  key_links:
    - from: "api/app/routers/search.py"
      to: "api/app/services/embedding.py"
      via: "EmbeddingService.embed(query_text) to generate query vector"
      pattern: "svc\\.embed"
    - from: "api/app/routers/search.py"
      to: "api/app/models/trace.py"
      via: "Trace.embedding.cosine_distance(query_vector) for ANN ordering"
      pattern: "cosine_distance"
    - from: "api/app/routers/search.py"
      to: "api/app/models/tag.py"
      via: "JOIN trace_tags + tags for tag pre-filtering with GROUP BY + HAVING"
      pattern: "trace_tags"
---

<objective>
Build the hybrid search endpoint that combines pgvector cosine ANN search with SQL tag pre-filtering and trust-weighted re-ranking, enabling agents to find traces by natural language, structured tags, or both.

Purpose: This is the core read path — the primary way agents discover relevant traces. Without this, CommonTrace has no search capability.
Output: POST /api/v1/traces/search endpoint that accepts a query string and optional tag filters, embeds the query using the same OpenAI model as stored traces, runs a hybrid SQL query (cosine ANN + tag filter), and returns results re-ranked by trust score.
</objective>

<execution_context>
@/home/bitnami/.claude/get-shit-done/workflows/execute-plan.md
@/home/bitnami/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search-discovery/03-RESEARCH.md
@.planning/phases/03-search-discovery/03-01-SUMMARY.md

# Critical existing code
@api/app/routers/traces.py — existing trace router pattern (auth + rate limit dependencies)
@api/app/dependencies.py — CurrentUser, DbSession, ReadRateLimit
@api/app/models/trace.py — Trace.embedding, Trace.trust_score, Trace.is_flagged
@api/app/models/tag.py — Tag, trace_tags join table
@api/app/services/embedding.py — EmbeddingService (from 03-01)
@api/app/main.py — router registration pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Search schemas and endpoint</name>
  <files>
    api/app/schemas/search.py
    api/app/routers/search.py
    api/app/main.py
  </files>
  <action>
**1. Create `api/app/schemas/search.py`:**

```python
from pydantic import BaseModel, Field
from typing import Optional
import uuid
from datetime import datetime

class TraceSearchRequest(BaseModel):
    q: str = Field(min_length=1, max_length=2000, description="Natural language search query")
    tags: list[str] = Field(default_factory=list, max_length=10, description="Filter by tags (AND semantics — all must match)")
    limit: int = Field(default=10, ge=1, le=50, description="Max results to return")

class TraceSearchResult(BaseModel):
    id: uuid.UUID
    title: str
    context_text: str
    solution_text: str
    trust_score: float
    status: str
    tags: list[str]
    similarity_score: float  # cosine similarity = 1 - distance
    combined_score: float    # trust-weighted final score
    contributor_id: uuid.UUID
    created_at: datetime

class TraceSearchResponse(BaseModel):
    results: list[TraceSearchResult]
    total: int  # number of results returned
    query: str  # echo back the query
```

**2. Create `api/app/routers/search.py`:**

Implement `POST /api/v1/traces/search`:

Router: `APIRouter(prefix="/api/v1", tags=["search"])`

The endpoint function signature:
```python
@router.post("/traces/search", response_model=TraceSearchResponse)
async def search_traces(
    body: TraceSearchRequest,
    user: CurrentUser,
    db: DbSession,
    _rate: ReadRateLimit,
) -> TraceSearchResponse:
```

Implementation steps:

**Step A: Embed the query text**
- Create an `EmbeddingService()` instance (or receive it from a dependency — but for simplicity, instantiate at module level as `_embedding_svc = EmbeddingService()`).
- Call `query_vector, _, _ = await _embedding_svc.embed(body.q)`.
- If `EmbeddingSkippedError` is raised (no API key): return HTTP 503 with detail "Search unavailable — embedding service not configured (OPENAI_API_KEY required)".

**Step B: Set HNSW search parameters**
- Execute `await db.execute(text("SET LOCAL hnsw.ef_search = 64"))` to improve recall. `SET LOCAL` scopes to the current transaction. Import `text` from `sqlalchemy`.

**Step C: Build the hybrid SQL query**

Constants:
```python
SEARCH_LIMIT_ANN = 100  # Over-fetch from ANN before re-ranking
```

Build the query:
```python
import math
from sqlalchemy import select, func, text
from sqlalchemy.orm import selectinload
from app.models.trace import Trace
from app.models.tag import Tag, trace_tags

distance_col = Trace.embedding.cosine_distance(query_vector).label("distance")

stmt = (
    select(Trace, distance_col)
    .where(Trace.embedding.is_not(None))
    .where(Trace.embedding_model_id == "text-embedding-3-small")
    .where(Trace.is_flagged.is_(False))
    .options(selectinload(Trace.tags))
    .order_by(distance_col)
    .limit(SEARCH_LIMIT_ANN)
)
```

**Step D: Tag pre-filter (if tags provided)**

If `body.tags` is not empty:
```python
if body.tags:
    stmt = (
        stmt
        .join(trace_tags, trace_tags.c.trace_id == Trace.id)
        .join(Tag, Tag.id == trace_tags.c.tag_id)
        .where(Tag.name.in_(body.tags))
        .group_by(Trace.id, Trace.embedding.cosine_distance(query_vector))
        .having(func.count(func.distinct(Tag.id)) == len(body.tags))
    )
```

IMPORTANT: In the `.group_by()`, use the full expression `Trace.embedding.cosine_distance(query_vector)` — NOT the alias `distance_col`. PostgreSQL requires the expression itself in GROUP BY, not a SELECT alias. This avoids Pitfall 3 from research.

Also normalize the tag names before querying: `[normalize_tag(t) for t in body.tags]`. Import `normalize_tag` from `app.services.tags`.

**Step E: Execute and re-rank**

```python
result = await db.execute(stmt)
rows = result.all()  # list of Row(Trace, distance)

# Trust-weighted re-ranking
ranked = sorted(
    rows,
    key=lambda r: (1.0 - r.distance) * math.log1p(max(0.0, r.Trace.trust_score) + 1),
    reverse=True,
)[:body.limit]
```

**Step F: Serialize response**

For each row in `ranked`:
```python
similarity = 1.0 - row.distance
combined = similarity * math.log1p(max(0.0, row.Trace.trust_score) + 1)
tag_names = [tag.name for tag in row.Trace.tags]
```

Build `TraceSearchResult` from the Trace fields + similarity_score + combined_score.

Return `TraceSearchResponse(results=results, total=len(results), query=body.q)`.

**3. Register search router in `api/app/main.py`:**

Add import: `from app.routers import search`
Add: `app.include_router(search.router)` after the existing router registrations.

Keep all existing imports and routes unchanged.
  </action>
  <verify>
1. `cd /home/bitnami/commontrace/api && uv run python -c "from app.routers.search import router; from app.schemas.search import TraceSearchRequest, TraceSearchResult, TraceSearchResponse; print('OK')"` — must print OK.
2. `grep -q 'search' /home/bitnami/commontrace/api/app/main.py && echo 'Search router registered'`.
3. `grep -q 'cosine_distance' /home/bitnami/commontrace/api/app/routers/search.py && echo 'Cosine distance used'`.
4. `grep -q 'hnsw.ef_search' /home/bitnami/commontrace/api/app/routers/search.py && echo 'HNSW ef_search set'`.
  </verify>
  <done>
POST /api/v1/traces/search endpoint works with: (a) semantic-only query, (b) tag-only filter, (c) hybrid query with both. Results are trust-weighted re-ranked. Flagged and unembedded traces are excluded.
  </done>
</task>

</tasks>

<verification>
Phase 3 Plan 02 verification:
1. Search schemas exist with request/result/response models
2. Search endpoint uses cosine_distance for ANN ordering
3. Tag filter uses GROUP BY + HAVING COUNT(DISTINCT) for AND semantics
4. Trust re-ranking formula: `(1 - distance) * log1p(max(0, trust_score) + 1)`
5. HNSW ef_search set to 64 via SET LOCAL before query
6. Flagged traces excluded, unembedded traces excluded, model-mismatched embeddings excluded
7. Search router registered in main.py
</verification>

<success_criteria>
- Endpoint accepts natural language query + optional tags + limit
- Cosine ANN + tag pre-filter executed in single SQL query
- Results ordered by trust-weighted combined score (not raw cosine distance)
- 503 returned when embedding service unavailable
- All imports resolve; router registered and reachable
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-discovery/03-02-SUMMARY.md`
</output>
