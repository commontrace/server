---
phase: 03-search-discovery
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - api/app/schemas/search.py
  - api/app/routers/search.py
  - api/app/main.py
autonomous: true

must_haves:
  truths:
    - "An agent can POST a natural language query to /api/v1/traces/search and receive semantically ranked results"
    - "An agent can filter search results by one or more tags and receive only traces matching ALL specified tags"
    - "An agent can search with tags only (no q) and receive results ordered by trust_score DESC without calling the embedding service"
    - "A single search request with both query text and tags returns results satisfying both semantic similarity and tag constraints"
    - "A trace with high trust_score ranks above an identical-distance trace with low trust_score"
    - "Traces with is_flagged=True do not appear in search results; embedding IS NULL traces are excluded only when q is provided"
    - "When q is provided but the embedding service is unavailable, the endpoint returns 503; when q is omitted, the endpoint works without the embedding service"
  artifacts:
    - path: "api/app/schemas/search.py"
      provides: "TraceSearchRequest, TraceSearchResult, TraceSearchResponse Pydantic models"
      contains: "TraceSearchRequest"
    - path: "api/app/routers/search.py"
      provides: "POST /api/v1/traces/search endpoint with hybrid query"
      contains: "cosine_distance"
    - path: "api/app/main.py"
      provides: "Search router registered on FastAPI app"
      contains: "search"
  key_links:
    - from: "api/app/routers/search.py"
      to: "api/app/services/embedding.py"
      via: "EmbeddingService.embed(query_text) to generate query vector"
      pattern: "svc\\.embed"
    - from: "api/app/routers/search.py"
      to: "api/app/models/trace.py"
      via: "Trace.embedding.cosine_distance(query_vector) for ANN ordering"
      pattern: "cosine_distance"
    - from: "api/app/routers/search.py"
      to: "api/app/models/tag.py"
      via: "JOIN trace_tags + tags for tag pre-filtering with GROUP BY + HAVING"
      pattern: "trace_tags"
---

<objective>
Build the hybrid search endpoint that combines pgvector cosine ANN search with SQL tag pre-filtering and trust-weighted re-ranking, enabling agents to find traces by natural language, structured tags, or both.

Purpose: This is the core read path — the primary way agents discover relevant traces. Without this, CommonTrace has no search capability.
Output: POST /api/v1/traces/search endpoint that accepts a query string and optional tag filters, embeds the query using the same OpenAI model as stored traces, runs a hybrid SQL query (cosine ANN + tag filter), and returns results re-ranked by trust score.
</objective>

<execution_context>
@/home/bitnami/.claude/get-shit-done/workflows/execute-plan.md
@/home/bitnami/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search-discovery/03-RESEARCH.md
@.planning/phases/03-search-discovery/03-01-SUMMARY.md

# Critical existing code
@api/app/routers/traces.py — existing trace router pattern (auth + rate limit dependencies)
@api/app/dependencies.py — CurrentUser, DbSession, ReadRateLimit
@api/app/models/trace.py — Trace.embedding, Trace.trust_score, Trace.is_flagged
@api/app/models/tag.py — Tag, trace_tags join table
@api/app/services/embedding.py — EmbeddingService (from 03-01)
@api/app/main.py — router registration pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Search schemas and endpoint</name>
  <files>
    api/app/schemas/search.py
    api/app/routers/search.py
    api/app/main.py
  </files>
  <action>
**1. Create `api/app/schemas/search.py`:**

```python
from pydantic import BaseModel, Field
from typing import Optional
import uuid
from datetime import datetime

class TraceSearchRequest(BaseModel):
    q: Optional[str] = Field(default=None, max_length=2000, description="Natural language search query (omit for tag-only search)")
    tags: list[str] = Field(default_factory=list, max_length=10, description="Filter by tags (AND semantics — all must match)")
    limit: int = Field(default=10, ge=1, le=50, description="Max results to return")

class TraceSearchResult(BaseModel):
    id: uuid.UUID
    title: str
    context_text: str
    solution_text: str
    trust_score: float
    status: str
    tags: list[str]
    similarity_score: float  # cosine similarity = 1 - distance
    combined_score: float    # trust-weighted final score
    contributor_id: uuid.UUID
    created_at: datetime

class TraceSearchResponse(BaseModel):
    results: list[TraceSearchResult]
    total: int  # number of results returned
    query: Optional[str] = None  # echo back the query (None for tag-only search)
```

**2. Create `api/app/routers/search.py`:**

Implement `POST /api/v1/traces/search`:

Router: `APIRouter(prefix="/api/v1", tags=["search"])`

The endpoint function signature:
```python
@router.post("/traces/search", response_model=TraceSearchResponse)
async def search_traces(
    body: TraceSearchRequest,
    user: CurrentUser,
    db: DbSession,
    _rate: ReadRateLimit,
) -> TraceSearchResponse:
```

Imports (at the top of the file):
```python
import math
import time
import structlog
from typing import Optional
from fastapi import APIRouter, HTTPException
from sqlalchemy import select, func, text
from sqlalchemy.orm import selectinload
from prometheus_client import Counter, Histogram
from app.dependencies import CurrentUser, DbSession
from app.middleware.rate_limiter import ReadRateLimit
from app.schemas.search import TraceSearchRequest, TraceSearchResult, TraceSearchResponse
from app.models.trace import Trace
from app.models.tag import Tag, trace_tags
from app.services.embedding import EmbeddingService, EmbeddingSkippedError
from app.services.tags import normalize_tag

log = structlog.get_logger()
_embedding_svc = EmbeddingService()

# Search metrics (defined here; 03-03 may consolidate into app.metrics)
search_requests = Counter(
    "commontrace_search_requests_total",
    "Total search requests",
    ["has_tags"],
)
search_duration = Histogram(
    "commontrace_search_duration_seconds",
    "End-to-end search latency",
    buckets=[0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.0],
)
```

Implementation steps:

**Step A: Embed the query text (only when q is provided)**
- If `body.q is not None`:
  - Try `query_vector, _, _ = await _embedding_svc.embed(body.q)`.
  - If `EmbeddingSkippedError` is raised (no API key): return HTTP 503 with detail "Search unavailable — embedding service not configured (OPENAI_API_KEY required)".
- If `body.q is None`:
  - Set `query_vector = None`.
  - Validate that `body.tags` is non-empty — if both `q` and `tags` are empty, raise HTTP 422 with detail "At least one of 'q' or 'tags' must be provided".

**Step B: Set HNSW search parameters (only when using vector search)**
- If `query_vector is not None`:
  - Execute `await db.execute(text("SET LOCAL hnsw.ef_search = 64"))` to improve recall. `SET LOCAL` scopes to the current transaction.

**Step C: Build the SQL query — two paths**

Constants:
```python
SEARCH_LIMIT_ANN = 100  # Over-fetch from ANN before re-ranking
```

**Path 1 — Semantic search (q is provided, query_vector exists):**
```python
distance_col = Trace.embedding.cosine_distance(query_vector).label("distance")

stmt = (
    select(Trace, distance_col)
    .where(Trace.embedding.is_not(None))
    .where(Trace.embedding_model_id == "text-embedding-3-small")
    .where(Trace.is_flagged.is_(False))
    .options(selectinload(Trace.tags))
    .order_by(distance_col)
    .limit(SEARCH_LIMIT_ANN)
)
```

**Path 2 — Tag-only search (q is None):**
```python
stmt = (
    select(Trace)
    .where(Trace.is_flagged.is_(False))
    .options(selectinload(Trace.tags))
    .order_by(Trace.trust_score.desc())
    .limit(body.limit)
)
```

Note: Tag-only search does NOT filter out embedding IS NULL traces — those are valid results when no semantic ranking is needed.

**Step D: Tag pre-filter (if tags provided)**

Normalize tags first: `normalized_tags = [normalize_tag(t) for t in body.tags]`. Import `normalize_tag` from `app.services.tags`.

If `normalized_tags` is not empty, apply tag filter to whichever path was chosen:

For Path 1 (semantic + tags):
```python
if normalized_tags:
    stmt = (
        stmt
        .join(trace_tags, trace_tags.c.trace_id == Trace.id)
        .join(Tag, Tag.id == trace_tags.c.tag_id)
        .where(Tag.name.in_(normalized_tags))
        .group_by(Trace.id, Trace.embedding.cosine_distance(query_vector))
        .having(func.count(func.distinct(Tag.id)) == len(normalized_tags))
    )
```

For Path 2 (tag-only):
```python
if normalized_tags:
    stmt = (
        stmt
        .join(trace_tags, trace_tags.c.trace_id == Trace.id)
        .join(Tag, Tag.id == trace_tags.c.tag_id)
        .where(Tag.name.in_(normalized_tags))
        .group_by(Trace.id)
        .having(func.count(func.distinct(Tag.id)) == len(normalized_tags))
    )
```

IMPORTANT: In Path 1's `.group_by()`, use the full expression `Trace.embedding.cosine_distance(query_vector)` — NOT the alias `distance_col`. PostgreSQL requires the expression itself in GROUP BY, not a SELECT alias. This avoids Pitfall 3 from research.

**Step E: Execute and re-rank**

For Path 1 (semantic):
```python
result = await db.execute(stmt)
rows = result.all()  # list of Row(Trace, distance)

# Trust-weighted re-ranking
ranked = sorted(
    rows,
    key=lambda r: (1.0 - r.distance) * math.log1p(max(0.0, r.Trace.trust_score) + 1),
    reverse=True,
)[:body.limit]
```

For Path 2 (tag-only):
```python
result = await db.execute(stmt)
rows = result.scalars().all()  # list of Trace (already ordered by trust_score DESC)
# No re-ranking needed — already ordered by trust_score
```

**Step F: Serialize response**

For Path 1 (semantic), for each row in `ranked`:
```python
similarity = 1.0 - row.distance
combined = similarity * math.log1p(max(0.0, row.Trace.trust_score) + 1)
tag_names = [tag.name for tag in row.Trace.tags]
```

For Path 2 (tag-only), for each trace in `rows`:
```python
similarity = 0.0  # No semantic similarity in tag-only mode
combined = float(trace.trust_score)
tag_names = [tag.name for tag in trace.tags]
```

Build `TraceSearchResult` from the Trace fields + similarity_score + combined_score.

Return `TraceSearchResponse(results=results, total=len(results), query=body.q)`.

**Step G: Search metrics instrumentation**

At the start of the endpoint function:
```python
start = time.monotonic()
search_requests.labels(has_tags=str(bool(body.tags)).lower()).inc()
```

At the end, before returning:
```python
search_duration.observe(time.monotonic() - start)
log.info("search_executed", query_len=len(body.q) if body.q else 0, tag_count=len(body.tags), result_count=len(results))
```

**3. Register search router in `api/app/main.py`:**

Add import: `from app.routers import search`
Add: `app.include_router(search.router)` after the existing router registrations.

Keep all existing imports and routes unchanged.
  </action>
  <verify>
1. `cd /home/bitnami/commontrace/api && uv run python -c "from app.routers.search import router; from app.schemas.search import TraceSearchRequest, TraceSearchResult, TraceSearchResponse; print('OK')"` — must print OK.
2. `grep -q 'search' /home/bitnami/commontrace/api/app/main.py && echo 'Search router registered'`.
3. `grep -q 'cosine_distance' /home/bitnami/commontrace/api/app/routers/search.py && echo 'Cosine distance used'`.
4. `grep -q 'hnsw.ef_search' /home/bitnami/commontrace/api/app/routers/search.py && echo 'HNSW ef_search set'`.
5. `cd /home/bitnami/commontrace/api && uv run python -c "from app.schemas.search import TraceSearchRequest; r = TraceSearchRequest(tags=['python']); assert r.q is None; print('Tag-only OK')"` — must print Tag-only OK (q is optional).
6. `grep -q 'search_duration' /home/bitnami/commontrace/api/app/routers/search.py && echo 'Search metrics wired'`.
7. `grep -q 'ReadRateLimit' /home/bitnami/commontrace/api/app/routers/search.py && echo 'ReadRateLimit imported'`.
  </verify>
  <done>
POST /api/v1/traces/search endpoint works with: (a) semantic-only query (q provided, tags empty), (b) tag-only filter (q omitted, tags provided) returning results ordered by trust_score DESC without calling embedding service, (c) hybrid query with both q and tags. Semantic results are trust-weighted re-ranked. Flagged traces excluded. Embedding IS NULL traces excluded only in semantic mode. 503 only returned when q is provided but embedding service is unavailable. Search metrics (search_requests counter, search_duration histogram) instrumented.
  </done>
</task>

</tasks>

<verification>
Phase 3 Plan 02 verification:
1. Search schemas exist with request (q is Optional[str] = None) / result / response models
2. Search endpoint uses cosine_distance for ANN ordering when q is provided
3. Tag filter uses GROUP BY + HAVING COUNT(DISTINCT) for AND semantics
4. Trust re-ranking formula: `(1 - distance) * log1p(max(0, trust_score) + 1)` for semantic queries
5. Tag-only search (q is None) returns results ordered by trust_score DESC, no embed call
6. HNSW ef_search set to 64 via SET LOCAL before query (only when q is provided)
7. Flagged traces excluded; unembedded traces excluded only in semantic mode
8. 503 only when q is provided but embedding service unavailable; tag-only never 503s
9. Search router registered in main.py
10. Search metrics (search_requests counter, search_duration histogram) instrumented
11. ReadRateLimit explicitly imported from app.middleware.rate_limiter
</verification>

<success_criteria>
- Endpoint accepts optional natural language query (q) + optional tags + limit
- When q is provided: cosine ANN + optional tag pre-filter, trust-weighted re-ranking
- When q is omitted: tag-only filter ordered by trust_score DESC, no embedding service call
- When both q and tags are omitted: 422 validation error
- 503 returned only when q is provided but embedding service unavailable
- Search metrics (search_requests, search_duration) instrumented
- All imports resolve (including ReadRateLimit); router registered and reachable
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-discovery/03-02-SUMMARY.md`
</output>
