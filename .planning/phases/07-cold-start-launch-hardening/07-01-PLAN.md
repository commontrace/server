---
phase: 07-cold-start-launch-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/fixtures/seed_traces.json
  - api/scripts/import_seeds.py
autonomous: true

must_haves:
  truths:
    - "A new agent searching CommonTrace finds 200+ validated traces covering React, PostgreSQL, Docker, and common API integrations"
    - "Search for 'react hooks useState' returns relevant seed traces on the first query after import + embedding completion"
    - "Seed traces are pre-validated (status=validated, is_seed=True, trust_score=1.0) and skip the confirmation flow"
    - "Re-running the import script is idempotent — existing seed traces are skipped, not duplicated"
  artifacts:
    - path: "api/fixtures/seed_traces.json"
      provides: "200+ curated seed traces with title, context, solution, tags, agent_model"
      contains: "react"
    - path: "api/scripts/import_seeds.py"
      provides: "Standalone async import script connecting to database via SQLAlchemy"
      contains: "import_seeds"
  key_links:
    - from: "api/scripts/import_seeds.py"
      to: "api/app/models/trace.py"
      via: "Trace ORM model with is_seed=True, status=validated"
      pattern: "is_seed.*True"
    - from: "api/scripts/import_seeds.py"
      to: "api/app/services/tags.py"
      via: "normalize_tag and validate_tag for tag processing"
      pattern: "normalize_tag|validate_tag"
    - from: "api/fixtures/seed_traces.json"
      to: "api/fixtures/sample_traces.json"
      via: "Same JSON schema (title, context, solution, tags, agent_model, agent_version)"
      pattern: "title.*context.*solution.*tags"
---

<objective>
Create 200+ high-quality, hand-curated seed traces covering common coding tasks and build an idempotent import pipeline to load them into the production database as pre-validated entries.

Purpose: Without seed data, a new agent's first search returns nothing — no value demonstrated, no engagement. Seed traces are the cold start solution: 200+ validated traces covering the most common tasks Claude Code agents encounter (React setup, PostgreSQL migrations, Docker configuration, FastAPI patterns, async Python, CI/CD, testing, authentication, API integrations).

Output: `api/fixtures/seed_traces.json` (200+ curated traces) and `api/scripts/import_seeds.py` (standalone async import script).
</objective>

<execution_context>
@/home/bitnami/.claude/get-shit-done/workflows/execute-plan.md
@/home/bitnami/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@api/fixtures/sample_traces.json
@api/app/models/trace.py
@api/app/models/user.py
@api/app/models/tag.py
@api/app/services/tags.py
@api/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create 200+ curated seed traces in seed_traces.json</name>
  <files>api/fixtures/seed_traces.json</files>
  <action>
Create `api/fixtures/seed_traces.json` containing 200+ hand-curated seed traces. Each trace follows the exact JSON schema established by `api/fixtures/sample_traces.json` (the 12 existing traces):

```json
{
  "title": "Descriptive, specific title",
  "context": "Concrete problem description an agent would encounter — not abstract",
  "solution": "Full solution with RUNNABLE code (not pseudocode) in markdown code blocks",
  "tags": ["language", "framework", "concept"],
  "agent_model": "claude-opus-4-6",
  "agent_version": "1.0"
}
```

**Quality bar (from existing sample_traces.json):**
- Title: specific and searchable (e.g., "Docker Compose healthcheck for PostgreSQL" NOT "Using Docker")
- Context: describes a concrete problem with enough detail to match semantic search queries
- Solution: includes actual runnable code in code blocks, explains key decisions
- Tags: 2-5 normalized tags per trace (lowercase, hyphens, no spaces)

**Topic distribution (aim for 50+ clusters, 3-5 traces per cluster):**

Category 1 — Python/FastAPI (40-50 traces):
- FastAPI middleware patterns, dependency injection, lifespan events
- Pydantic v2 validators, settings, custom types
- SQLAlchemy 2.0 async queries, relationships, bulk operations
- asyncio patterns, task groups, error handling
- pytest async testing, fixtures, mocking
- structlog/logging configuration

Category 2 — Database (30-40 traces):
- PostgreSQL indexing strategies, partial indexes, EXPLAIN ANALYZE
- Alembic migration patterns (async, manual DDL, rollback)
- pgvector HNSW configuration and cosine similarity search
- Connection pooling, transactions, deadlock prevention
- Redis caching patterns, pub/sub, data structures

Category 3 — Docker/Infrastructure (25-35 traces):
- Docker Compose service dependencies, healthchecks, volumes
- Dockerfile multi-stage builds, layer caching
- Docker networking, environment variable injection
- Nginx reverse proxy configuration
- SSL/TLS certificate setup

Category 4 — JavaScript/TypeScript/React (30-40 traces):
- React hooks (useState, useEffect, useCallback, useMemo)
- React component patterns (error boundaries, suspense, portals)
- TypeScript utility types, generics, discriminated unions
- Next.js app router, server components, API routes
- Node.js async patterns, streams, error handling

Category 5 — CI/CD and DevOps (20-25 traces):
- GitHub Actions workflows, caching, matrix builds
- Deployment patterns (Docker, Vercel, fly.io)
- Environment variable management across environments

Category 6 — API Integrations (15-20 traces):
- OpenAI API (embeddings, chat completions, streaming)
- Stripe payments (checkout, webhooks, subscriptions)
- OAuth2/OIDC integration patterns
- Webhook handling and verification

Category 7 — Testing (15-20 traces):
- pytest patterns (fixtures, parametrize, conftest)
- Integration testing with Docker (testcontainers pattern)
- Mocking external APIs (httpx, responses library)
- Test database setup and teardown

**Do NOT include** any of the 12 traces already in `sample_traces.json` — check titles for overlap.

The file must be valid JSON. Each trace must have all 6 fields (title, context, solution, tags, agent_model, agent_version).
  </action>
  <verify>
Run: `python3 -c "import json; d=json.load(open('api/fixtures/seed_traces.json')); print(f'{len(d)} traces'); assert len(d) >= 200; assert all(set(t.keys()) >= {'title','context','solution','tags','agent_model','agent_version'} for t in d); tags=set(); [tags.update(t['tags']) for t in d]; print(f'{len(tags)} unique tags'); assert len(tags) >= 30"`
  </verify>
  <done>seed_traces.json contains 200+ traces, each with title/context/solution/tags/agent_model/agent_version, covering 30+ unique tags across 7 topic categories</done>
</task>

<task type="auto">
  <name>Task 2: Build idempotent seed import pipeline script</name>
  <files>api/scripts/import_seeds.py</files>
  <action>
Create `api/scripts/import_seeds.py` — a standalone async Python script that imports seed traces from `api/fixtures/seed_traces.json` into the database.

**Script behavior:**
1. Connect to the database using `settings.database_url` from `app.config`
2. Get or create a seed contributor user with email `seeds@commontrace.internal`, `display_name="CommonTrace Seeds"`, `is_seed=True`
3. Read and parse `api/fixtures/seed_traces.json`
4. For each trace:
   a. **Idempotency check:** `SELECT ... WHERE title = :title AND is_seed IS TRUE` — skip if exists
   b. Create `Trace` with:
      - `status=TraceStatus.validated` (pre-validated, bypasses confirmation flow)
      - `is_seed=True`
      - `trust_score=1.0`
      - `confirmation_count=2` (>= `validation_threshold=2` default)
      - `contributor_id` = seed user ID
      - `agent_model` and `agent_version` from JSON
      - `embedding=NULL` (the existing embedding worker picks these up via its `embedding IS NULL` poll)
   c. Process tags: normalize with `normalize_tag()`, validate with `validate_tag()`, get-or-create Tag rows, insert into `trace_tags` join table
5. Commit the transaction
6. Print summary: `Seed import complete: {N} inserted, {M} skipped`

**Key implementation details:**
- Use `from app.config import settings` for database URL
- Use `from app.models.trace import Trace, TraceStatus`
- Use `from app.models.user import User`
- Use `from app.models.tag import Tag, trace_tags`
- Use `from app.services.tags import normalize_tag, validate_tag`
- Use `sqlalchemy.ext.asyncio.create_async_engine` and `async_sessionmaker`
- Use `sqlalchemy.insert(trace_tags).values(trace_id=..., tag_id=...)` for join table (not relationship append — per codebase convention)
- Set `expire_on_commit=False` on the session factory
- Use `pathlib.Path` for file path resolution
- Support running from project root: `python -m api.scripts.import_seeds` OR `cd api && python -m scripts.import_seeds`
- Add `sys.path` manipulation if needed to resolve `app` imports when running from project root
- The script should accept an optional `--fixtures-path` argument defaulting to `api/fixtures/seed_traces.json`

**Do NOT generate embeddings** — traces are inserted with `embedding=NULL`. The existing embedding worker (Phase 3) polls `WHERE embedding IS NULL` every 5 seconds in batches of 10. For 200 traces, this takes ~2 minutes to complete.

Add a `__main__` block:
```python
if __name__ == "__main__":
    asyncio.run(import_seeds(Path("api/fixtures/seed_traces.json")))
```
  </action>
  <verify>
Run: `python3 -c "import ast; tree=ast.parse(open('api/scripts/import_seeds.py').read()); funcs=[n.name for n in ast.walk(tree) if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef))]; print(funcs); assert 'import_seeds' in funcs; assert 'get_or_create_seed_user' in funcs"` to verify structure. Then verify imports: `grep -c 'normalize_tag\|validate_tag\|TraceStatus\|is_seed' api/scripts/import_seeds.py` should return 4+.
  </verify>
  <done>import_seeds.py exists, imports the correct ORM models and tag services, implements idempotent insertion with is_seed=True and status=validated, and has a runnable __main__ block</done>
</task>

</tasks>

<verification>
1. `api/fixtures/seed_traces.json` is valid JSON with 200+ entries
2. Each trace has all required fields (title, context, solution, tags, agent_model, agent_version)
3. At least 30 unique tags across the traces
4. `api/scripts/import_seeds.py` uses the existing Trace/User/Tag models and tag normalization service
5. Import script inserts traces with `is_seed=True`, `status="validated"`, `trust_score=1.0`, `confirmation_count=2`
6. Idempotency: existing seed traces are skipped by title match
7. Embeddings are NOT generated by the script (left NULL for the embedding worker)
</verification>

<success_criteria>
- 200+ curated seed traces exist in `api/fixtures/seed_traces.json`
- Traces cover 7 topic categories with 30+ unique tags
- `api/scripts/import_seeds.py` connects to the database, creates a seed user, and inserts all traces as pre-validated
- Re-running the script produces "0 inserted, N skipped" output
- After import + embedding worker processing, `POST /api/v1/traces/search {"q": "react hooks useState"}` returns relevant results
</success_criteria>

<output>
After completion, create `.planning/phases/07-cold-start-launch-hardening/07-01-SUMMARY.md`
</output>
