---
phase: 06-claude-code-skill
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - skill/hooks/hooks.json
  - skill/hooks/session_start.py
  - skill/hooks/stop.py
autonomous: true

must_haves:
  truths:
    - "At session start in a coding project, the hook silently queries CommonTrace and injects relevant traces into agent context — without user prompting"
    - "If CommonTrace is unavailable or no relevant context is detected, the session starts normally with zero delay or output"
    - "After an agent completes a task, the Stop hook prompts the agent to consider contributing to CommonTrace"
    - "The Stop hook never causes an infinite loop — stop_hook_active is checked first"
    - "The contribution prompt fires at most once per session — a flag file prevents re-prompting"
  artifacts:
    - path: "skill/hooks/hooks.json"
      provides: "Hook event configuration for SessionStart and Stop"
      contains: "SessionStart"
    - path: "skill/hooks/session_start.py"
      provides: "Context detection and silent auto-query logic"
      contains: "detect_context"
    - path: "skill/hooks/stop.py"
      provides: "Post-task contribution prompt with loop prevention"
      contains: "stop_hook_active"
  key_links:
    - from: "skill/hooks/hooks.json"
      to: "skill/hooks/session_start.py"
      via: "command field referencing ${CLAUDE_PLUGIN_ROOT}/hooks/session_start.py"
      pattern: "session_start.py"
    - from: "skill/hooks/hooks.json"
      to: "skill/hooks/stop.py"
      via: "command field referencing ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"
      pattern: "stop.py"
    - from: "skill/hooks/session_start.py"
      to: "CommonTrace API (direct HTTP)"
      via: "urllib.request call to COMMONTRACE_API_BASE_URL/api/v1/traces/search"
      pattern: "urllib.request"
---

<objective>
Implement the SessionStart auto-query hook and Stop contribution-prompt hook.

Purpose: Satisfy SKIL-03 (silent auto-query at task start) and SKIL-04 (post-task contribution prompt). These hooks make CommonTrace work automatically — agents benefit from shared knowledge without being asked, and they're reminded to give back after solving problems.

Output: hooks.json configuration plus two Python hook scripts that handle context detection, silent search injection, and contribution prompting with loop prevention.
</objective>

<execution_context>
@/home/bitnami/.claude/get-shit-done/workflows/execute-plan.md
@/home/bitnami/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-claude-code-skill/06-RESEARCH.md
@.planning/phases/06-claude-code-skill/06-01-SUMMARY.md

## Critical Design Decisions From Research

### SessionStart Hook — Direct API Call (Option B)

The hook script CANNOT call MCP tools (hooks are shell commands, not Claude agent turns). Research Open Question #1 resolved: **use direct HTTP call to the CommonTrace backend API (bypassing MCP)** to guarantee "silently queries CommonTrace." The hook uses Python's `urllib.request` (stdlib, zero deps) to call `POST /api/v1/traces/search` directly with `COMMONTRACE_API_KEY`.

This means:
- The hook needs `COMMONTRACE_API_BASE_URL` env var (defaults to `http://localhost:8000` — the FastAPI backend, NOT the MCP server)
- The hook needs `COMMONTRACE_API_KEY` env var for authentication
- The hook formats results as `additionalContext` text that Claude reads at session start
- If either env var is missing or the call fails, the hook exits 0 silently (session starts normally)

### SessionStart Matcher

Use `"matcher": "startup"` so the hook fires ONLY on new sessions — not on resume, clear, or compact (which would re-inject context uselessly).

### Stop Hook — Loop Prevention

1. Check `stop_hook_active` field first — if true, exit 0 immediately (prevents infinite loop within one stop cycle)
2. Write a session-scoped flag file to `/tmp/commontrace-prompted-{session_id}` after first prompt — check it before prompting again (prevents prompting on every Claude response in the same session). Use `session_id` from stdin JSON (primary) or `os.getppid()` as fallback (stable parent process PID). Do NOT use `os.getpid()` — it creates a new PID per hook invocation.
3. Only detect task completion via signal words in `last_assistant_message`

### Context Detection Heuristics (SKIL-03)

Start simple, plan for iteration:
1. Git repo present (`.git/` in cwd) — if not, skip entirely
2. Source code files detected (scan cwd for .py, .ts, .js, .go, .rs, .java, .rb, .tsx, .jsx)
3. Build query from: project language + framework detection (check pyproject.toml, package.json, Cargo.toml, go.mod)
4. If no language detected despite git repo, skip — don't query with empty/generic terms

### Timeout Budget

- SessionStart hook has 5-second timeout (configured in hooks.json)
- Direct HTTP call to backend should timeout at 3 seconds (leaves 2s for Python startup + context detection)
- Stop hook has 10-second timeout (more generous — runs after task completion, not blocking start)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Hooks configuration and SessionStart auto-query</name>
  <files>
    skill/hooks/hooks.json
    skill/hooks/session_start.py
  </files>
  <action>
Create the hooks configuration and the SessionStart auto-query script:

**skill/hooks/hooks.json:**
```json
{
  "description": "CommonTrace auto-query at session start, contribution prompt at task completion",
  "hooks": {
    "SessionStart": [
      {
        "matcher": "startup",
        "hooks": [
          {
            "type": "command",
            "command": "python3 ${CLAUDE_PLUGIN_ROOT}/hooks/session_start.py",
            "timeout": 5
          }
        ]
      }
    ],
    "Stop": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py",
            "timeout": 10
          }
        ]
      }
    ]
  }
}
```

Key: `"matcher": "startup"` ensures auto-query only on new sessions, not resume/clear/compact.

**skill/hooks/session_start.py:**

This script detects coding context, makes a direct HTTP call to the CommonTrace backend API, and injects results as `additionalContext`.

Implementation details:

1. **Read stdin** as JSON — contains `cwd` and session metadata
2. **Context detection** (the `detect_context` function):
   - Check if `cwd/.git` exists — if not, exit 0 (not a code project)
   - Scan cwd for source files: `.py`, `.ts`, `.js`, `.tsx`, `.jsx`, `.go`, `.rs`, `.java`, `.rb`
   - Detect primary language from most frequent extension in top-level files
   - Check for framework indicators:
     - `pyproject.toml` → check for fastapi, django, flask in contents
     - `package.json` → check for react, next, express, vue in contents
     - `Cargo.toml` → rust project
     - `go.mod` → go project
   - Build query string: e.g., "python fastapi common patterns and solutions" or "typescript react common patterns and solutions"
   - If no language detected, exit 0 — don't query with empty terms
3. **Direct API call** (the `search_commontrace` function):
   - Read `COMMONTRACE_API_BASE_URL` env var (default: `http://localhost:8000`)
   - Read `COMMONTRACE_API_KEY` env var — if missing, exit 0 silently
   - POST to `{base_url}/api/v1/traces/search` with JSON body: `{"q": query, "tags": [detected_language], "limit": 3}`
   - Use `urllib.request.urlopen` with 3-second timeout (stdlib, zero deps)
   - Set headers: `Content-Type: application/json`, `X-API-Key: {api_key}`
   - Parse JSON response, extract results list
   - If response has 0 results or any error occurs, exit 0 silently
4. **Format and inject results**:
   - Format each result as: `"[title] — [first 100 chars of context_text]... Solution: [first 150 chars of solution_text]... (trace ID: [id])"`
   - Output JSON to stdout:
     ```json
     {
       "hookSpecificOutput": {
         "hookEventName": "SessionStart",
         "additionalContext": "CommonTrace found relevant knowledge for this project:\n\n1. [formatted result 1]\n2. [formatted result 2]\n...\n\nUse /trace:search for more specific queries."
       }
     }
     ```
5. **Error handling**: ALL exceptions caught at top level — print nothing, exit 0. Never block session start.

Use ONLY stdlib: `json`, `os`, `sys`, `urllib.request`, `urllib.error`. No third-party imports. The script must work on any system with Python 3.12+.

Make the script executable (`chmod +x`).
  </action>
  <verify>
```bash
# Check hooks.json is valid JSON with correct structure
python3 -c "import json; d=json.load(open('skill/hooks/hooks.json')); assert 'SessionStart' in d['hooks']; assert 'Stop' in d['hooks']; print('hooks.json OK')"

# Check session_start.py exists and is executable
ls -la skill/hooks/session_start.py
test -x skill/hooks/session_start.py && echo "executable" || echo "not executable"

# Check it uses only stdlib imports (no third-party)
python3 -c "
import ast, sys
tree = ast.parse(open('skill/hooks/session_start.py').read())
for node in ast.walk(tree):
    if isinstance(node, (ast.Import, ast.ImportFrom)):
        mod = node.module if isinstance(node, ast.ImportFrom) else node.names[0].name
        if mod and mod.split('.')[0] not in ('json', 'os', 'sys', 'urllib', 'pathlib', 'typing'):
            print(f'Non-stdlib import: {mod}', file=sys.stderr)
            sys.exit(1)
print('stdlib-only imports OK')
"

# Check it handles missing stdin gracefully (simulates no-cwd scenario)
echo '{}' | python3 skill/hooks/session_start.py; echo "exit code: $?"
```
  </verify>
  <done>hooks.json exists with SessionStart (matcher: startup, 5s timeout) and Stop (10s timeout) entries. session_start.py exists, is executable, uses only stdlib imports, reads context from cwd, calls CommonTrace API directly via urllib, and exits 0 on any failure.</done>
</task>

<task type="auto">
  <name>Task 2: Stop hook for post-task contribution prompt</name>
  <files>
    skill/hooks/stop.py
  </files>
  <action>
Create the Stop hook script that prompts the agent to contribute after task completion:

**skill/hooks/stop.py:**

Implementation details:

1. **Read stdin** as JSON — contains `stop_hook_active`, `last_assistant_message`, and session metadata
2. **Loop prevention (CRITICAL — first two checks):**
   - Check `stop_hook_active` — if `True`, exit 0 immediately (prevents infinite loop within one stop cycle)
   - Derive session key: `session_key = data.get("session_id") or str(os.getppid())`. Check for flag file at `/tmp/commontrace-prompted-{session_key}`. If file exists, exit 0 (already prompted this session). Do NOT use `os.getpid()` — each hook invocation spawns a new Python process with a unique PID, so the flag would never be found.
3. **Task completion detection:**
   - Read `last_assistant_message` from stdin data
   - Check for completion signal words (case-insensitive): "completed", "done", "finished", "implemented", "fixed", "solved", "resolved", "deployed", "working now", "successfully"
   - Also check for completion patterns: "task is complete", "changes are ready", "commit created", "all tests pass"
   - If no completion signals found, exit 0
4. **Contribution prompt:**
   - Write the flag file to prevent re-prompting: create `/tmp/commontrace-prompted-{session_key}` with current timestamp
   - Output JSON to stdout:
     ```json
     {
       "decision": "block",
       "reason": "Before we wrap up: if you just solved a problem that other agents might face, consider sharing it with the CommonTrace knowledge base. Use /trace:contribute to start the contribution flow, or just say 'skip' to finish."
     }
     ```
5. **Error handling**: ALL exceptions caught at top level — print nothing, exit 0. Never prevent Claude from stopping.

Use ONLY stdlib: `json`, `os`, `sys`, `pathlib`. No third-party imports.

Make the script executable (`chmod +x`).

COMPLETION_SIGNALS list — keep it conservative to avoid false positives:
```python
COMPLETION_SIGNALS = [
    "completed", "done", "finished", "implemented", "fixed",
    "solved", "resolved", "deployed", "successfully"
]

COMPLETION_PATTERNS = [
    "task is complete", "changes are ready", "commit created",
    "all tests pass", "tests pass", "working now"
]
```

The detection checks `last_assistant_message.lower()` for any signal word as a standalone word boundary (not substring — "done" should match "I'm done" but not "abandoned"). Use simple word boundary check: split message into words, check if any signal word appears in the word list. For patterns, check if pattern appears as substring in the lowered message.
  </action>
  <verify>
```bash
# Check stop.py exists and is executable
ls -la skill/hooks/stop.py
test -x skill/hooks/stop.py && echo "executable" || echo "not executable"

# Check it uses only stdlib imports
python3 -c "
import ast, sys
tree = ast.parse(open('skill/hooks/stop.py').read())
for node in ast.walk(tree):
    if isinstance(node, (ast.Import, ast.ImportFrom)):
        mod = node.module if isinstance(node, ast.ImportFrom) else node.names[0].name
        if mod and mod.split('.')[0] not in ('json', 'os', 'sys', 'pathlib', 'typing', 're'):
            print(f'Non-stdlib import: {mod}', file=sys.stderr)
            sys.exit(1)
print('stdlib-only imports OK')
"

# Test: stop_hook_active=true should exit 0 with no output
OUTPUT=$(echo '{"stop_hook_active": true, "last_assistant_message": "I have completed the task."}' | python3 skill/hooks/stop.py)
test -z "$OUTPUT" && echo "stop_hook_active=true: correctly exits silently" || echo "FAIL: output when stop_hook_active is true"

# Test: no completion signals should exit 0 with no output
OUTPUT=$(echo '{"stop_hook_active": false, "last_assistant_message": "Here is the file content you asked for."}' | python3 skill/hooks/stop.py)
test -z "$OUTPUT" && echo "no-completion: correctly exits silently" || echo "FAIL: output when no completion signal"

# Test: completion signal should produce block decision
OUTPUT=$(echo '{"stop_hook_active": false, "last_assistant_message": "I have successfully implemented the feature."}' | python3 skill/hooks/stop.py)
echo "$OUTPUT" | python3 -c "import json,sys; d=json.load(sys.stdin); assert d['decision']=='block'; print('completion-detected: correctly blocks with prompt')"

# Clean up flag file from test
rm -f /tmp/commontrace-prompted-*
```
  </verify>
  <done>stop.py exists, is executable, uses only stdlib imports, checks stop_hook_active first (exits 0 if true), checks session flag file (exits 0 if already prompted), detects task completion via signal words, and outputs a block decision with contribution prompt. Verified: no output when stop_hook_active is true, no output when no completion signal, block decision when completion detected.</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Complete hooks directory structure:
   ```
   skill/hooks/
   ├── hooks.json
   ├── session_start.py  (executable)
   └── stop.py           (executable)
   ```
2. hooks.json is valid JSON with both SessionStart and Stop events
3. SessionStart hook fires only on "startup" (not resume/clear/compact)
4. session_start.py makes direct HTTP call to backend API (not MCP) using only stdlib
5. session_start.py exits 0 silently on: no git repo, no source files, missing API key, API error, timeout, 0 results
6. stop.py checks stop_hook_active first (prevents infinite loop)
7. stop.py checks session flag file (prevents re-prompting)
8. stop.py detects task completion via conservative signal word list
9. Both scripts use only Python stdlib (no third-party imports)
</verification>

<success_criteria>
- hooks.json configures SessionStart (5s timeout, startup matcher) and Stop (10s timeout) events
- session_start.py detects coding context, queries CommonTrace directly via urllib, injects results as additionalContext
- session_start.py never blocks session start — all failures exit 0 silently
- stop.py never causes infinite loop — stop_hook_active and flag file both checked
- stop.py prompts contribution only on task completion, at most once per session
- All scripts use only Python stdlib (json, os, sys, urllib, pathlib)
</success_criteria>

<output>
After completion, create `.planning/phases/06-claude-code-skill/06-02-SUMMARY.md`
</output>
